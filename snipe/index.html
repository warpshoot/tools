<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Sniper Scope</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      touch-action: manipulation;
    }

    #container {
      position: relative;
      width: 100%;
      height: 100%;
    }

    #video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    #segmentation-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }

    #scope-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    #reticle {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: min(80vw, 80vh);
      height: min(80vw, 80vh);
    }

    /* スコープの黒縁（ビネット） */
    #vignette {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(
        circle at center,
        transparent 30%,
        rgba(0,0,0,0.3) 45%,
        rgba(0,0,0,0.7) 55%,
        rgba(0,0,0,0.95) 65%,
        #000 70%
      );
      pointer-events: none;
    }

    /* 射撃エフェクト */
    #muzzle-flash {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at center, rgba(255,200,100,0.8) 0%, rgba(255,100,50,0.4) 30%, transparent 60%);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.05s;
    }

    #muzzle-flash.fire {
      opacity: 1;
    }

    /* 画面揺れ用 */
    #container.recoil {
      animation: recoil 0.15s ease-out;
    }

    @keyframes recoil {
      0% { transform: translate(0, 0); }
      20% { transform: translate(0, 8px); }
      40% { transform: translate(-2px, 4px); }
      60% { transform: translate(2px, 2px); }
      100% { transform: translate(0, 0); }
    }

    /* タップ位置のヒットマーカー */
    .hit-marker {
      position: absolute;
      width: 40px;
      height: 40px;
      pointer-events: none;
      animation: hitFade 0.3s ease-out forwards;
    }

    @keyframes hitFade {
      0% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(0.5);
      }
      50% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.2);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(1);
      }
    }

    /* 開始ボタン */
    #start-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }

    #start-btn {
      padding: 20px 50px;
      font-size: 24px;
      background: #333;
      color: #0f0;
      border: 2px solid #0f0;
      border-radius: 8px;
      cursor: pointer;
      font-family: monospace;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    #start-btn:active {
      background: #0f0;
      color: #000;
    }

    .hidden {
      display: none !important;
    }

    /* 距離表示（フレーバー） */
    #hud {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: rgba(255, 255, 255, 0.9);
      font-family: monospace;
      font-size: 12px;
      pointer-events: none;
      text-shadow: 0 0 5px rgba(0,0,0,0.8);
    }

    /* ステータス表示 */
    #status {
      position: absolute;
      bottom: 20px;
      right: 20px;
      color: rgba(255, 255, 255, 0.7);
      font-family: monospace;
      font-size: 10px;
      pointer-events: none;
      text-shadow: 0 0 5px rgba(0,0,0,0.8);
      text-align: right;
    }

    /* デバッグ情報 */
    #debug {
      position: absolute;
      top: 20px;
      left: 20px;
      color: rgba(255, 255, 0, 0.8);
      font-family: monospace;
      font-size: 9px;
      pointer-events: none;
      text-shadow: 0 0 5px rgba(0,0,0,0.8);
      max-width: 300px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
</head>
<body>
  <div id="container">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="segmentation-canvas"></canvas>

    <div id="scope-overlay">
      <div id="vignette"></div>

      <svg id="reticle" viewBox="0 0 200 200">
        <!-- メインのクロスヘア -->
        <g stroke="rgba(0,0,0,0.8)" stroke-width="1">
          <line x1="100" y1="0" x2="100" y2="85"/>
          <line x1="100" y1="115" x2="100" y2="200"/>
          <line x1="0" y1="100" x2="85" y2="100"/>
          <line x1="115" y1="100" x2="200" y2="100"/>
        </g>

        <!-- 中心のドット -->
        <circle cx="100" cy="100" r="2" fill="rgba(255,0,0,0.9)" id="center-dot"/>

        <!-- ミルドット（距離目盛り） -->
        <g fill="rgba(0,0,0,0.6)">
          <circle cx="100" cy="70" r="1.5"/>
          <circle cx="100" cy="55" r="1.5"/>
          <circle cx="100" cy="40" r="1.5"/>
          <circle cx="100" cy="130" r="1.5"/>
          <circle cx="100" cy="145" r="1.5"/>
          <circle cx="100" cy="160" r="1.5"/>
          <circle cx="70" cy="100" r="1.5"/>
          <circle cx="55" cy="100" r="1.5"/>
          <circle cx="40" cy="100" r="1.5"/>
          <circle cx="130" cy="100" r="1.5"/>
          <circle cx="145" cy="100" r="1.5"/>
          <circle cx="160" cy="100" r="1.5"/>
        </g>

        <!-- レンジファインダー目盛り -->
        <g stroke="rgba(0,0,0,0.5)" stroke-width="0.5">
          <line x1="85" y1="105" x2="85" y2="110"/>
          <line x1="90" y1="105" x2="90" y2="108"/>
          <line x1="95" y1="105" x2="95" y2="108"/>
          <line x1="105" y1="105" x2="105" y2="108"/>
          <line x1="110" y1="105" x2="110" y2="108"/>
          <line x1="115" y1="105" x2="115" y2="110"/>
        </g>
      </svg>

      <div id="muzzle-flash"></div>
    </div>

    <div id="hud">
      <div>WIND: 2.3 MPH</div>
      <div>ELEV: +1.2 MOA</div>
      <div>RNG: --- M</div>
    </div>

    <div id="status">
      <div>MODEL: Loading...</div>
      <div>DETECT: Inactive</div>
      <div>ORIENT: Inactive</div>
    </div>

    <div id="debug"></div>

    <div id="start-screen">
      <button id="start-btn">ENGAGE</button>
    </div>
  </div>

  <script>
    const video = document.getElementById('video');
    const container = document.getElementById('container');
    const startScreen = document.getElementById('start-screen');
    const startBtn = document.getElementById('start-btn');
    const muzzleFlash = document.getElementById('muzzle-flash');
    const scopeOverlay = document.getElementById('scope-overlay');
    const segmentationCanvas = document.getElementById('segmentation-canvas');
    const segmentationCtx = segmentationCanvas.getContext('2d');
    const centerDot = document.getElementById('center-dot');
    const statusDiv = document.getElementById('status');
    const debugDiv = document.getElementById('debug');

    // 人物検出状態
    let isPersonDetected = false;
    let selfieSegmentation = null;
    let modelLoaded = false;
    let frameCount = 0;
    let fps = 0;
    let lastFpsUpdate = Date.now();
    let orientationEventCount = 0;
    let permissionStatus = 'Not Requested';
    let locationData = {
      lat: 'N/A',
      lon: 'N/A',
      altitude: 'N/A'
    };

    // ステータス更新関数
    function updateStatus(model, detect, orient) {
      statusDiv.innerHTML = `
        <div>MODEL: ${model}</div>
        <div>DETECT: ${detect}</div>
        <div>ORIENT: ${orient}</div>
      `;
    }

    // 射撃音を生成（Web Audio API）
    let audioCtx = null;

    function createGunshot() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }

      const now = audioCtx.currentTime;

      // ノイズバースト（爆発音）
      const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.15, audioCtx.sampleRate);
      const noiseData = noiseBuffer.getChannelData(0);
      for (let i = 0; i < noiseData.length; i++) {
        noiseData[i] = (Math.random() * 2 - 1) * Math.exp(-i / (audioCtx.sampleRate * 0.02));
      }

      const noiseSource = audioCtx.createBufferSource();
      noiseSource.buffer = noiseBuffer;

      const noiseFilter = audioCtx.createBiquadFilter();
      noiseFilter.type = 'lowpass';
      noiseFilter.frequency.value = 1000;

      const noiseGain = audioCtx.createGain();
      noiseGain.gain.setValueAtTime(0.8, now);
      noiseGain.gain.exponentialDecayTo?.(0.01, now + 0.15) || noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

      noiseSource.connect(noiseFilter);
      noiseFilter.connect(noiseGain);
      noiseGain.connect(audioCtx.destination);
      noiseSource.start(now);

      // 低音のサンプ（銃の重み）
      const osc = audioCtx.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(80, now);
      osc.frequency.exponentialRampToValueAtTime(30, now + 0.1);

      const oscGain = audioCtx.createGain();
      oscGain.gain.setValueAtTime(0.5, now);
      oscGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

      osc.connect(oscGain);
      oscGain.connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.2);

      // クリック音（トリガー/メカニカル音）
      const clickOsc = audioCtx.createOscillator();
      clickOsc.type = 'square';
      clickOsc.frequency.value = 2000;

      const clickGain = audioCtx.createGain();
      clickGain.gain.setValueAtTime(0.1, now);
      clickGain.gain.exponentialRampToValueAtTime(0.001, now + 0.02);

      clickOsc.connect(clickGain);
      clickGain.connect(audioCtx.destination);
      clickOsc.start(now);
      clickOsc.stop(now + 0.03);
    }

    // 振動
    function vibrate() {
      if (navigator.vibrate) {
        navigator.vibrate([50, 30, 20]);
      }
    }

    // ヒットマーカー表示
    function showHitMarker(x, y) {
      const marker = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      marker.classList.add('hit-marker');
      marker.style.left = x + 'px';
      marker.style.top = y + 'px';
      marker.setAttribute('viewBox', '0 0 40 40');
      marker.innerHTML = `
        <g stroke="white" stroke-width="2">
          <line x1="8" y1="8" x2="15" y2="15"/>
          <line x1="32" y1="8" x2="25" y2="15"/>
          <line x1="8" y1="32" x2="15" y2="25"/>
          <line x1="32" y1="32" x2="25" y2="25"/>
        </g>
      `;
      container.appendChild(marker);
      setTimeout(() => marker.remove(), 300);
    }

    // 射撃！
    function fire(e) {
      // マズルフラッシュ
      muzzleFlash.classList.add('fire');
      setTimeout(() => muzzleFlash.classList.remove('fire'), 80);

      // リコイル
      container.classList.add('recoil');
      setTimeout(() => container.classList.remove('recoil'), 150);

      // 音
      createGunshot();

      // 振動
      vibrate();

      // ヒットマーカー（中央に表示）
      const rect = container.getBoundingClientRect();
      showHitMarker(rect.width / 2, rect.height / 2);
    }

    // MediaPipeセグメンテーション初期化
    function initSegmentation() {
      try {
        updateStatus('Loading...', 'Inactive', orientationEventCount > 0 ? 'Active' : 'Inactive');

        selfieSegmentation = new SelfieSegmentation({
          locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`
        });

        selfieSegmentation.setOptions({
          modelSelection: 1, // 0: 一般モデル, 1: ランドスケープモデル（高精度）
          selfieMode: false
        });

        selfieSegmentation.onResults(onSegmentationResults);

        console.log('MediaPipe initialized');
      } catch (err) {
        console.error('MediaPipe init error:', err);
        updateStatus('Error', 'Inactive', deviceData.pitch !== 0 ? 'Active' : 'Inactive');
      }
    }

    // セグメンテーション結果の処理
    function onSegmentationResults(results) {
      try {
        if (!modelLoaded) {
          modelLoaded = true;
          console.log('Model loaded successfully');
        }

        frameCount++;

        // FPS計算（1秒ごと）
        const now = Date.now();
        if (now - lastFpsUpdate >= 1000) {
          fps = frameCount;
          frameCount = 0;
          lastFpsUpdate = now;
        }

        // Canvasのサイズを調整
        segmentationCanvas.width = video.videoWidth;
        segmentationCanvas.height = video.videoHeight;

        segmentationCtx.clearRect(0, 0, segmentationCanvas.width, segmentationCanvas.height);

        // セグメンテーションマスクを一時Canvasに描画
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = segmentationCanvas.width;
        tempCanvas.height = segmentationCanvas.height;

        tempCtx.drawImage(results.segmentationMask, 0, 0, tempCanvas.width, tempCanvas.height);
        const maskData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

        // 輪郭線を検出して描画
        const outputData = segmentationCtx.createImageData(segmentationCanvas.width, segmentationCanvas.height);
        const width = maskData.width;
        const height = maskData.height;

        for (let y = 1; y < height - 1; y++) {
          for (let x = 1; x < width - 1; x++) {
            const idx = (y * width + x) * 4;
            const pixel = maskData.data[idx]; // R channel (grayscale)

            if (pixel > 128) { // 人物領域
              // 周囲をチェック（エッジ検出）
              const top = maskData.data[((y - 1) * width + x) * 4];
              const bottom = maskData.data[((y + 1) * width + x) * 4];
              const left = maskData.data[(y * width + (x - 1)) * 4];
              const right = maskData.data[(y * width + (x + 1)) * 4];

              if (top < 128 || bottom < 128 || left < 128 || right < 128) {
                // エッジ検出 - 赤い輪郭線を描画
                outputData.data[idx] = 255;     // R
                outputData.data[idx + 1] = 0;   // G
                outputData.data[idx + 2] = 0;   // B
                outputData.data[idx + 3] = 255; // A
              }
            }
          }
        }

        segmentationCtx.putImageData(outputData, 0, 0);

        // 中央の点が人物領域内にあるかチェック
        const centerX = Math.floor(width / 2);
        const centerY = Math.floor(height / 2);
        const centerIdx = (centerY * width + centerX) * 4;
        const centerPixel = maskData.data[centerIdx];

        isPersonDetected = centerPixel > 128;

        // 中央の点の色を変更
        if (isPersonDetected) {
          centerDot.setAttribute('fill', 'rgba(0,255,0,0.9)'); // 緑
        } else {
          centerDot.setAttribute('fill', 'rgba(255,0,0,0.9)'); // 赤
        }

        // ステータス更新
        updateStatus('Ready', `${fps}fps`, orientationEventCount > 0 ? 'Active' : 'Inactive');
      } catch (err) {
        console.error('Segmentation error:', err);
        updateStatus('Error', 'Failed', deviceData.pitch !== 0 ? 'Active' : 'Inactive');
      }
    }

    // カメラフレームをセグメンテーション処理
    async function processFrame() {
      if (selfieSegmentation && video.readyState >= 2) {
        await selfieSegmentation.send({ image: video });
      }
      requestAnimationFrame(processFrame);
    }

    // カメラ起動
    async function startCamera() {
      try {
        // DeviceOrientation パーミッション要求（iOS 13+）
        // ★重要: カメラの前に要求してユーザージェスチャーのコンテキストを維持
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
          try {
            console.log('Requesting DeviceOrientation permission...');
            const permission = await DeviceOrientationEvent.requestPermission();
            permissionStatus = permission; // 'granted', 'denied', or 'default'
            console.log('DeviceOrientation permission:', permission);

            if (permission === 'granted') {
              console.log('DeviceOrientation permission granted');
            } else {
              console.warn('DeviceOrientation permission denied or not granted:', permission);
              alert('端末の傾き検出が無効になっています。一部の機能が制限されます。');
            }
          } catch (err) {
            console.error('DeviceOrientation permission error:', err);
            permissionStatus = 'Error: ' + err.message;
          }
        } else {
          permissionStatus = 'No Permission API';
        }

        // カメラのパーミッション要求
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: 'environment',
            width: { ideal: 1920 },
            height: { ideal: 1080 }
          },
          audio: false
        });
        video.srcObject = stream;
        startScreen.classList.add('hidden');

        // MediaPipeセグメンテーション開始
        initSegmentation();

        // ビデオが再生開始したらフレーム処理を開始
        video.addEventListener('loadeddata', () => {
          processFrame();
        });

        // タップで射撃
        container.addEventListener('click', fire);
        container.addEventListener('touchstart', (e) => {
          e.preventDefault();
          fire(e);
        }, { passive: false });

      } catch (err) {
        console.error('Camera error:', err);
        alert('カメラへのアクセスを許可してください');
      }
    }

    startBtn.addEventListener('click', startCamera);

    // 位置情報取得
    if (navigator.geolocation) {
      navigator.geolocation.watchPosition(
        (position) => {
          locationData.lat = position.coords.latitude.toFixed(6);
          locationData.lon = position.coords.longitude.toFixed(6);
          locationData.altitude = position.coords.altitude ? position.coords.altitude.toFixed(1) + 'm' : 'N/A';
          console.log('Location updated:', locationData);
        },
        (error) => {
          console.warn('Geolocation error:', error);
        },
        { enableHighAccuracy: true }
      );
    }

    // 端末の傾きデータ
    let deviceData = {
      pitch: 0,
      roll: 0,
      azimuth: 0
    };

    // デバッグ情報を更新
    function updateDebugInfo() {
      const isHTTPS = window.location.protocol === 'https:';
      const hasDeviceOrientation = typeof DeviceOrientationEvent !== 'undefined';
      const hasPermissionAPI = hasDeviceOrientation && typeof DeviceOrientationEvent.requestPermission === 'function';
      const userAgent = navigator.userAgent;
      const isMobile = /iPhone|iPad|iPod|Android/i.test(userAgent);

      debugDiv.innerHTML = `
        <div>HTTPS: ${isHTTPS ? 'YES' : 'NO (Required!)'}</div>
        <div>Mobile: ${isMobile ? 'YES' : 'NO (Required!)'}</div>
        <div>DeviceOrientation: ${hasDeviceOrientation ? 'Supported' : 'Not Supported'}</div>
        <div>Permission API: ${hasPermissionAPI ? 'YES (iOS 13+)' : 'NO'}</div>
        <div>Permission: ${permissionStatus}</div>
        <div>Events: ${orientationEventCount}</div>
        <div style="font-size: 8px; margin-top: 5px;">${userAgent.substring(0, 50)}...</div>
      `;
    }

    // 初回更新
    updateDebugInfo();
    setInterval(updateDebugInfo, 1000);

    // DeviceOrientation APIで傾きを取得
    if (window.DeviceOrientationEvent) {
      window.addEventListener('deviceorientation', (e) => {
        orientationEventCount++;

        // beta: 前後の傾き (-180 to 180)
        // gamma: 左右の傾き (-90 to 90)
        // alpha: 方位 (0 to 360)
        if (e.beta !== null) deviceData.pitch = e.beta.toFixed(1);
        if (e.gamma !== null) deviceData.roll = e.gamma.toFixed(1);
        if (e.alpha !== null) deviceData.azimuth = e.alpha.toFixed(0);

        // 最初のイベントをログ出力
        if (orientationEventCount === 1) {
          console.log('DeviceOrientation event received:', e.alpha, e.beta, e.gamma);
        }
      }, true);

      console.log('DeviceOrientation listener registered');
    } else {
      console.warn('DeviceOrientationEvent not supported');
    }

    // HUD更新（時刻、場所、天気）
    setInterval(() => {
      const now = new Date();
      const timeStr = now.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit', second: '2-digit' });

      // 天気（模擬データ - 外部API未実装）
      const weather = 'Clear';
      const temp = '22°C';

      document.getElementById('hud').innerHTML = `
        <div>TIME: ${timeStr}</div>
        <div>LAT: ${locationData.lat}</div>
        <div>LON: ${locationData.lon}</div>
      `;
    }, 100);
  </script>

</body>
</html>
