<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Air Hockey</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        #gameCanvas {
            display: block;
            background: linear-gradient(180deg, #001a33 0%, #000 50%, #1a0033 100%);
            touch-action: none;
        }

        .hud {
            position: absolute;
            width: 100%;
            pointer-events: none;
        }

        .hud-top {
            top: 40px;
            transform: rotate(180deg);
        }

        .hud-bottom {
            bottom: 40px;
        }

        .score {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            font-size: 48px;
            font-weight: bold;
        }

        .score span {
            text-shadow: 0 0 20px currentColor;
        }

        .score .p1 {
            color: #ff6600;
        }

        .score .p2 {
            color: #00ffff;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            display: none;
            border: 2px solid rgba(255, 255, 255, 0.3);
            z-index: 100;
        }

        .game-over.show {
            display: block;
        }

        .game-over h2 {
            font-size: 36px;
            margin-bottom: 16px;
            text-shadow: 0 0 20px currentColor;
        }

        .game-over p {
            font-size: 20px;
            margin-bottom: 24px;
            opacity: 0.8;
        }

        .restart-btn {
            background: linear-gradient(90deg, #ff0066, #ff6600);
            color: #fff;
            border: none;
            padding: 16px 32px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            pointer-events: auto;
        }

        .restart-btn:active {
            opacity: 0.8;
        }

        .instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            opacity: 0;
            animation: fadeOut 4s forwards;
        }

        @keyframes fadeOut {
            0%, 60% {
                opacity: 1;
            }
            100% {
                opacity: 0;
            }
        }

        .instructions h3 {
            font-size: 24px;
            margin-bottom: 12px;
        }

        .instructions p {
            font-size: 16px;
            opacity: 0.8;
        }

        .hyper-indicator {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            transition: all 0.3s ease;
        }

        .hyper-indicator.p1 {
            bottom: 80px;
            left: 20px;
        }

        .hyper-indicator.p2 {
            top: 80px;
            right: 20px;
            transform: rotate(180deg);
        }

        .hyper-indicator.available {
            background: rgba(255, 215, 0, 0.3);
            border: 3px solid rgba(255, 215, 0, 0.8);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
            animation: pulse 2s infinite;
        }

        .hyper-indicator.active {
            background: rgba(255, 0, 0, 0.5);
            border: 3px solid rgba(255, 0, 0, 1);
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.9);
            animation: activePulse 0.5s infinite;
        }

        .hyper-indicator.used {
            background: rgba(100, 100, 100, 0.2);
            border: 3px solid rgba(100, 100, 100, 0.5);
            opacity: 0.4;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
        }

        @keyframes activePulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 30px rgba(255, 0, 0, 0.9);
            }
            50% {
                transform: scale(1.15);
                box-shadow: 0 0 50px rgba(255, 0, 0, 1);
            }
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>

    <div class="hud hud-top">
        <div class="score">
            <span class="p2" id="score2">0</span>
        </div>
    </div>

    <div class="hud hud-bottom">
        <div class="score">
            <span class="p1" id="score1">0</span>
        </div>
    </div>

    <div class="hyper-indicator p1 available" id="hyper1">‚ö°</div>
    <div class="hyper-indicator p2 available" id="hyper2">‚ö°</div>

    <div class="instructions">
        <h3>„Éâ„É©„ÉÉ„Ç∞„Åó„Å¶„Éë„ÉÉ„ÇØ„ÇíÊâì„Å°Ëøî„ÅõÔºÅ</h3>
        <p>3ÁÇπÂÖàÂèñ„ÅßÂãùÂà© | „Éà„É™„Éó„É´„Çø„ÉÉ„Éó„Åß„Éè„Ç§„Éë„ÉºÁô∫Âãï</p>
    </div>

    <div class="game-over" id="gameOver">
        <h2 id="winnerText">Player 1 WIN!</h2>
        <p>„Åä„ÇÅ„Åß„Å®„ÅÜ„Åî„Åñ„ÅÑ„Åæ„ÅôÔºÅ</p>
        <button class="restart-btn" onclick="restartGame()">„ÇÇ„ÅÜ‰∏ÄÂ∫¶</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Ë™øÊï¥ÂèØËÉΩ„Å™„Éë„É©„É°„Éº„Çø
        const PHYSICS = {
            puckFriction: 0.99,        // „Éë„ÉÉ„ÇØ„ÅÆÊë©Êì¶Ôºà0.99 = „Çà„ÅèÊªë„ÇãÔºâ
            puckMaxSpeed: 15,          // „Éë„ÉÉ„ÇØ„ÅÆÊúÄÂ§ßÈÄüÂ∫¶
            paddleSpeedMultiplier: 1.5 // „Éë„Éâ„É´„ÅÆÈÄüÂ∫¶„Åå„Éë„ÉÉ„ÇØ„Å´‰∏é„Åà„ÇãÂΩ±Èüø
        };

        // „Ç≤„Éº„É†Áä∂ÊÖã
        let gameState = {
            running: true,
            score1: 0,
            score2: 0,
            winScore: 3
        };

        // „Éë„ÉÉ„ÇØ
        let puck = {
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            radius: 15,
            trail: [],
            isHyper: false, // „Éè„Ç§„Éë„ÉºÁä∂ÊÖã
            hyperOwner: null // „Éè„Ç§„Éë„Éº„Éë„ÉÉ„ÇØ„ÇíÊâì„Å£„Åü„Éó„É¨„Ç§„É§„ÉºÔºà1 or 2Ôºâ
        };

        // „Éë„Éâ„É´
        let paddle1 = {
            x: 0,
            y: 0,
            prevX: 0,
            prevY: 0,
            radius: 35,
            baseRadius: 35,
            isDragging: false,
            touchId: null,
            hyperState: 'available', // 'available', 'active', 'used'
            isDestroyed: false,
            tapTimes: [], // „Éà„É™„Éó„É´„Çø„ÉÉ„ÉóÊ§úÂá∫Áî®
            lastTapTime: 0
        };

        let paddle2 = {
            x: 0,
            y: 0,
            prevX: 0,
            prevY: 0,
            radius: 35,
            baseRadius: 35,
            isDragging: false,
            touchId: null,
            hyperState: 'available',
            isDestroyed: false,
            tapTimes: [],
            lastTapTime: 0
        };

        // „Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫Ë®≠ÂÆö
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // „Ç≤„Éº„É†„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆ‰ΩçÁΩÆ„ÇíË™øÊï¥
            puck.x = canvas.width / 2;
            puck.y = canvas.height / 2;

            paddle1.x = canvas.width / 2;
            paddle1.y = canvas.height - 100;
            paddle1.prevX = paddle1.x;
            paddle1.prevY = paddle1.y;

            paddle2.x = canvas.width / 2;
            paddle2.y = 100;
            paddle2.prevX = paddle2.x;
            paddle2.prevY = paddle2.y;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // „Éë„Éº„ÉÜ„Ç£„ÇØ„É´
        const particles = [];

        // „Éè„Ç§„Éë„Éº„Éë„ÉØ„ÉºÈñ¢ÈÄ£
        function activateHyper(paddle, playerNum) {
            if (paddle.hyperState !== 'available' || paddle.isDestroyed) return;

            paddle.hyperState = 'active';
            paddle.radius = paddle.baseRadius * 1.5;
            updateHyperUI();

            // ÂäπÊûúÈü≥ÁöÑ„Å™„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØÔºà„Éë„Éº„ÉÜ„Ç£„ÇØ„É´Ôºâ
            createHyperActivationEffect(paddle.x, paddle.y, playerNum);
        }

        function deactivateHyper(paddle) {
            if (paddle.hyperState === 'active') {
                paddle.hyperState = 'used';
                paddle.radius = paddle.baseRadius;
                updateHyperUI();
            }
        }

        function updateHyperUI() {
            const hyper1 = document.getElementById('hyper1');
            const hyper2 = document.getElementById('hyper2');

            hyper1.className = `hyper-indicator p1 ${paddle1.hyperState}`;
            hyper2.className = `hyper-indicator p2 ${paddle2.hyperState}`;
        }

        function checkTripleTap(paddle, playerNum) {
            const now = Date.now();
            paddle.tapTimes.push(now);

            // 1Áßí‰ª•ÂÜÖ„ÅÆ„Çø„ÉÉ„Éó„ÅÆ„Åø‰øùÊåÅ
            paddle.tapTimes = paddle.tapTimes.filter(t => now - t < 1000);

            // „Éà„É™„Éó„É´„Çø„ÉÉ„ÉóÊ§úÂá∫
            if (paddle.tapTimes.length >= 3) {
                activateHyper(paddle, playerNum);
                paddle.tapTimes = [];
            }
        }

        // „Éè„Ç§„Éë„ÉºÁô∫Âãï„Ç®„Éï„Çß„ÇØ„Éà
        function createHyperActivationEffect(x, y, playerNum) {
            for (let i = 0; i < 30; i++) {
                const angle = (Math.PI * 2 * i) / 30;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * 8,
                    vy: Math.sin(angle) * 8,
                    life: 1,
                    color: playerNum === 1 ? '#ff0066' : '#00ffff'
                });
            }
        }

        // „Éë„Éâ„É´Á†¥Â£ä„Ç®„Éï„Çß„ÇØ„Éà
        function createPaddleDestroyEffect(x, y, playerNum) {
            for (let i = 0; i < 50; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    life: 1.5,
                    color: playerNum === 1 ? '#ff6600' : '#00ffff'
                });
            }
        }

        // „Ç¥„Éº„É´ÊèèÁîª
        function drawGoals() {
            const goalWidth = 200;
            const goalX = (canvas.width - goalWidth) / 2;

            // Player 1„ÅÆ„Ç¥„Éº„É´Ôºà‰∏ãÔºâ
            ctx.strokeStyle = '#ff6600';
            ctx.lineWidth = 8;
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ff6600';
            ctx.beginPath();
            ctx.moveTo(goalX, canvas.height - 5);
            ctx.lineTo(goalX + goalWidth, canvas.height - 5);
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Player 2„ÅÆ„Ç¥„Éº„É´Ôºà‰∏äÔºâ
            ctx.strokeStyle = '#00ffff';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#00ffff';
            ctx.beginPath();
            ctx.moveTo(goalX, 5);
            ctx.lineTo(goalX + goalWidth, 5);
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        // ‰∏≠Â§ÆÁ∑öÊèèÁîª
        function drawCenterLine() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 10]);
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2);
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // „Éë„ÉÉ„ÇØÊèèÁîª
        function drawPuck() {
            // ËªåË∑°Ôºà„É™„ÉÉ„ÉÅ„Å™„Éï„Çß„Éº„Éâ„Ç¢„Ç¶„ÉàÂÜÜÂΩ¢„Éà„É¨„Ç§„É´Ôºâ
            for (let i = 0; i < puck.trail.length; i++) {
                const point = puck.trail[i];
                const age = i / puck.trail.length; // 0ÔºàÂè§„ÅÑÔºâ„Åã„Çâ1ÔºàÊñ∞„Åó„ÅÑÔºâ
                const opacity = age * (puck.isHyper ? 0.9 : 0.6);
                const radius = puck.radius * (0.3 + age * 0.7);

                // „Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥Ôºà„Éè„Ç§„Éë„ÉºÊôÇ„ÅØËµ§Ôºâ
                const gradient = ctx.createRadialGradient(point.x, point.y, 0, point.x, point.y, radius);
                if (puck.isHyper) {
                    gradient.addColorStop(0, `rgba(255, 0, 0, ${opacity})`);
                    gradient.addColorStop(0.5, `rgba(255, 50, 0, ${opacity * 0.8})`);
                    gradient.addColorStop(1, `rgba(255, 100, 0, 0)`);
                } else {
                    gradient.addColorStop(0, `rgba(255, 255, 100, ${opacity})`);
                    gradient.addColorStop(0.5, `rgba(255, 200, 50, ${opacity * 0.7})`);
                    gradient.addColorStop(1, `rgba(255, 150, 0, 0)`);
                }

                ctx.beginPath();
                ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
            }

            // „Éë„ÉÉ„ÇØÊú¨‰Ωì
            const gradient = ctx.createRadialGradient(puck.x, puck.y, 0, puck.x, puck.y, puck.radius);
            if (puck.isHyper) {
                gradient.addColorStop(0, '#fff');
                gradient.addColorStop(0.3, '#ff0000');
                gradient.addColorStop(1, '#ff6600');
            } else {
                gradient.addColorStop(0, '#fff');
                gradient.addColorStop(0.5, '#ffff00');
                gradient.addColorStop(1, '#ff6600');
            }

            ctx.beginPath();
            ctx.arc(puck.x, puck.y, puck.radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.shadowBlur = puck.isHyper ? 40 : 25;
            ctx.shadowColor = puck.isHyper ? '#ff0000' : '#ffff00';
            ctx.fill();
            ctx.shadowBlur = 0;

            // „Éè„Ç§„É©„Ç§„Éà
            ctx.beginPath();
            ctx.arc(puck.x - 5, puck.y - 5, 5, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fill();

            // „Éè„Ç§„Éë„ÉºÊôÇ„ÅÆÁ®≤Â¶ª„Ç®„Éï„Çß„ÇØ„Éà
            if (puck.isHyper) {
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    const angle = (Date.now() / 100 + i * Math.PI * 2 / 3) % (Math.PI * 2);
                    const x1 = puck.x + Math.cos(angle) * puck.radius;
                    const y1 = puck.y + Math.sin(angle) * puck.radius;
                    const x2 = puck.x + Math.cos(angle) * (puck.radius + 10);
                    const y2 = puck.y + Math.sin(angle) * (puck.radius + 10);
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
            }
        }

        // „Éë„Éâ„É´ÊèèÁîª
        function drawPaddle(paddle, color1, color2) {
            if (paddle.isDestroyed) return; // Á†¥Â£ä„Åï„Çå„Åü„ÇâÊèèÁîª„Åó„Å™„ÅÑ

            // „Éè„Ç§„Éë„ÉºÊôÇ„ÅÆ„Ç™„Éº„É©
            if (paddle.hyperState === 'active') {
                const time = Date.now() / 200;
                for (let i = 0; i < 3; i++) {
                    const offset = i * 15 + Math.sin(time + i) * 5;
                    ctx.beginPath();
                    ctx.arc(paddle.x, paddle.y, paddle.radius + offset, 0, Math.PI * 2);
                    ctx.strokeStyle = color1;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.3 - i * 0.1;
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            }

            const gradient = ctx.createRadialGradient(paddle.x, paddle.y, 0, paddle.x, paddle.y, paddle.radius);
            gradient.addColorStop(0, color1);
            gradient.addColorStop(1, color2);

            ctx.beginPath();
            ctx.arc(paddle.x, paddle.y, paddle.radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.globalAlpha = 0.6;
            ctx.shadowBlur = paddle.hyperState === 'active' ? 40 : 20;
            ctx.shadowColor = color1;
            ctx.fill();
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;

            // Â§ñÊû†
            ctx.beginPath();
            ctx.arc(paddle.x, paddle.y, paddle.radius, 0, Math.PI * 2);
            ctx.strokeStyle = color1;
            ctx.lineWidth = paddle.hyperState === 'active' ? 5 : 3;
            ctx.stroke();
        }

        // Ë°ùÁ™ÅÂà§ÂÆö
        function checkCollision(obj1, obj2) {
            const dx = obj1.x - obj2.x;
            const dy = obj1.y - obj2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < obj1.radius + obj2.radius;
        }

        // „Éë„Éâ„É´„Å®„Éë„ÉÉ„ÇØ„ÅÆË°ùÁ™ÅÂá¶ÁêÜ
        function handlePaddleCollision(paddle, playerNum) {
            if (paddle.isDestroyed) return; // Á†¥Â£ä„Åï„Çå„Åü„Éë„Éâ„É´„ÅØË°ùÁ™Å„Åó„Å™„ÅÑ

            if (checkCollision(puck, paddle)) {
                // „Éè„Ç§„Éë„Éº„Éë„ÉÉ„ÇØ„Åå„Éë„Éâ„É´„Å´ÂΩì„Åü„Å£„ÅüÂ†¥Âêà„ÄÅ„Éë„Éâ„É´Á†¥Â£ä
                if (puck.isHyper && puck.hyperOwner !== playerNum) {
                    paddle.isDestroyed = true;
                    createPaddleDestroyEffect(paddle.x, paddle.y, playerNum);
                    puck.isHyper = false; // „Éè„Ç§„Éë„ÉºÁä∂ÊÖã„ÅØË≤´ÈÄöÂæå„Å´Ëß£Èô§
                    puck.hyperOwner = null;
                    return; // Ë≤´ÈÄö„Åô„Çã„ÅÆ„ÅßÂèçÂ∞Ñ„Åó„Å™„ÅÑ
                }

                // Ë°ùÁ™ÅÊñπÂêë
                const dx = puck.x - paddle.x;
                const dy = puck.y - paddle.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Ê≠£Ë¶èÂåñ
                const nx = dx / distance;
                const ny = dy / distance;

                // „Éë„Éâ„É´„ÅÆÈÄüÂ∫¶„ÇíË®àÁÆó
                const paddleVx = paddle.x - paddle.prevX;
                const paddleVy = paddle.y - paddle.prevY;

                // ÂèçÂ∞Ñ„Éô„ÇØ„Éà„É´
                const dotProduct = puck.vx * nx + puck.vy * ny;
                puck.vx = puck.vx - 2 * dotProduct * nx;
                puck.vy = puck.vy - 2 * dotProduct * ny;

                // „Éë„Éâ„É´„ÅÆÈÄüÂ∫¶„ÇíÂä†ÁÆó
                let speedMult = PHYSICS.paddleSpeedMultiplier;

                // „Éè„Ç§„Éë„ÉºÁô∫Âãï‰∏≠„Å´„Éë„ÉÉ„ÇØ„ÇíÂºæ„ÅÑ„ÅüÂ†¥Âêà
                if (paddle.hyperState === 'active') {
                    speedMult *= 2; // 2ÂÄçÈÄü
                    puck.isHyper = true;
                    puck.hyperOwner = playerNum;
                    deactivateHyper(paddle); // „Éè„Ç§„Éë„ÉºÁä∂ÊÖãËß£Èô§
                }

                puck.vx += paddleVx * speedMult;
                puck.vy += paddleVy * speedMult;

                // ÊúÄÂ§ßÈÄüÂ∫¶Âà∂ÈôêÔºà„Éè„Ç§„Éë„ÉºÊôÇ„ÅØ2ÂÄçÔºâ
                const maxSpeed = puck.isHyper ? PHYSICS.puckMaxSpeed * 2 : PHYSICS.puckMaxSpeed;
                const speed = Math.sqrt(puck.vx * puck.vx + puck.vy * puck.vy);
                if (speed > maxSpeed) {
                    puck.vx = (puck.vx / speed) * maxSpeed;
                    puck.vy = (puck.vy / speed) * maxSpeed;
                }

                // „Éë„ÉÉ„ÇØ„ÇíÊäº„ÅóÂá∫„Åô
                const overlap = puck.radius + paddle.radius - distance;
                puck.x += nx * overlap;
                puck.y += ny * overlap;

                // „Ç®„Éï„Çß„ÇØ„Éà
                createHitEffect(puck.x, puck.y);
            }
        }

        // „Éí„ÉÉ„Éà„Ç®„Éï„Çß„ÇØ„Éà
        function createHitEffect(x, y) {
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    life: 1,
                    color: '#ffff00'
                });
            }
        }

        // Â£ÅË°ùÁ™Å„Ç®„Éï„Çß„ÇØ„Éà
        function createWallEffect(x, y) {
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5,
                    life: 1,
                    color: '#ffffff'
                });
            }
        }

        // „Ç¥„Éº„É´„Ç®„Éï„Çß„ÇØ„Éà
        function createGoalEffect(y) {
            for (let i = 0; i < 50; i++) {
                particles.push({
                    x: canvas.width / 2 + (Math.random() - 0.5) * 200,
                    y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1,
                    color: y < canvas.height / 2 ? '#00ffff' : '#ff6600'
                });
            }
        }

        // „Éë„Éº„ÉÜ„Ç£„ÇØ„É´Êõ¥Êñ∞
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02;

                if (p.life > 0) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    ctx.fillStyle = p.color.replace(')', `, ${p.life})`).replace('rgb', 'rgba');
                    ctx.fill();
                } else {
                    particles.splice(i, 1);
                }
            }
        }

        // „Éë„ÉÉ„ÇØÊõ¥Êñ∞
        function updatePuck() {
            if (!gameState.running) return;

            // „Éë„ÉÉ„ÇØ„ÅÆ‰ΩçÁΩÆÊõ¥Êñ∞
            puck.x += puck.vx;
            puck.y += puck.vy;

            // Êë©Êì¶
            puck.vx *= PHYSICS.puckFriction;
            puck.vy *= PHYSICS.puckFriction;

            // ËªåË∑°„ÇíËøΩÂä†
            puck.trail.push({ x: puck.x, y: puck.y });
            if (puck.trail.length > 15) {
                puck.trail.shift();
            }

            // Â£Å„Å®„ÅÆË°ùÁ™ÅÔºàÂ∑¶Âè≥Ôºâ
            if (puck.x - puck.radius < 0) {
                puck.x = puck.radius;
                puck.vx = -puck.vx * 0.8;
                createWallEffect(puck.x, puck.y);
            }
            if (puck.x + puck.radius > canvas.width) {
                puck.x = canvas.width - puck.radius;
                puck.vx = -puck.vx * 0.8;
                createWallEffect(puck.x, puck.y);
            }

            // „Ç¥„Éº„É´Âà§ÂÆö
            const goalWidth = 200;
            const goalX = (canvas.width - goalWidth) / 2;

            // Player 2„ÅÆ„Ç¥„Éº„É´Ôºà‰∏äÔºâ
            if (puck.y - puck.radius < 0) {
                if (puck.x > goalX && puck.x < goalX + goalWidth) {
                    // „Ç¥„Éº„É´ÔºÅ
                    gameState.score1++;
                    updateScore();
                    createGoalEffect(puck.y);
                    resetPuck();
                } else {
                    puck.y = puck.radius;
                    puck.vy = -puck.vy * 0.8;
                    createWallEffect(puck.x, puck.y);
                }
            }

            // Player 1„ÅÆ„Ç¥„Éº„É´Ôºà‰∏ãÔºâ
            if (puck.y + puck.radius > canvas.height) {
                if (puck.x > goalX && puck.x < goalX + goalWidth) {
                    // „Ç¥„Éº„É´ÔºÅ
                    gameState.score2++;
                    updateScore();
                    createGoalEffect(puck.y);
                    resetPuck();
                } else {
                    puck.y = canvas.height - puck.radius;
                    puck.vy = -puck.vy * 0.8;
                    createWallEffect(puck.x, puck.y);
                }
            }

            // „Éë„Éâ„É´„Å®„ÅÆË°ùÁ™Å
            handlePaddleCollision(paddle1, 1);
            handlePaddleCollision(paddle2, 2);

            // „Éë„Éâ„É´„ÅÆÂâçÂõû‰ΩçÁΩÆ„ÇíÊõ¥Êñ∞ÔºàÊ¨°„Éï„É¨„Éº„É†Áî®Ôºâ
            paddle1.prevX = paddle1.x;
            paddle1.prevY = paddle1.y;
            paddle2.prevX = paddle2.x;
            paddle2.prevY = paddle2.y;
        }

        // „Éë„ÉÉ„ÇØ„É™„Çª„ÉÉ„Éà
        function resetPuck() {
            puck.x = canvas.width / 2;

            // „É©„É≥„ÉÄ„É†„ÅßP1„Åæ„Åü„ÅØP2„ÅÆ„Ç®„É™„Ç¢„ÅÆ‰∏≠Â§Æ„Å´ÈÖçÁΩÆ
            if (Math.random() < 0.5) {
                // Player 1„ÅÆ„Ç®„É™„Ç¢Ôºà‰∏ãÂÅ¥Ôºâ
                puck.y = canvas.height * 0.75;
                puck.vx = (Math.random() - 0.5) * 4;
                puck.vy = -(Math.random() * 3 + 2); // ‰∏äÂêë„Åç
            } else {
                // Player 2„ÅÆ„Ç®„É™„Ç¢Ôºà‰∏äÂÅ¥Ôºâ
                puck.y = canvas.height * 0.25;
                puck.vx = (Math.random() - 0.5) * 4;
                puck.vy = Math.random() * 3 + 2; // ‰∏ãÂêë„Åç
            }

            puck.trail = [];
            puck.isHyper = false;
            puck.hyperOwner = null;

            // Á†¥Â£ä„Åï„Çå„Åü„Éë„Éâ„É´„ÇíÂæ©Ê¥ª
            paddle1.isDestroyed = false;
            paddle2.isDestroyed = false;
            paddle1.radius = paddle1.baseRadius;
            paddle2.radius = paddle2.baseRadius;
        }

        // „Çπ„Ç≥„Ç¢Êõ¥Êñ∞
        function updateScore() {
            document.getElementById('score1').textContent = gameState.score1;
            document.getElementById('score2').textContent = gameState.score2;

            if (gameState.score1 >= gameState.winScore || gameState.score2 >= gameState.winScore) {
                endGame();
            }
        }

        // „Ç≤„Éº„É†ÁµÇ‰∫Ü
        function endGame() {
            gameState.running = false;
            const gameOver = document.getElementById('gameOver');
            const winnerText = document.getElementById('winnerText');

            if (gameState.score1 >= gameState.winScore) {
                winnerText.textContent = 'Player 1 WIN! üèÜ';
                winnerText.style.color = '#ff6600';
            } else {
                winnerText.textContent = 'Player 2 WIN! üèÜ';
                winnerText.style.color = '#00ffff';
            }

            gameOver.classList.add('show');
        }

        // „Ç≤„Éº„É†ÂÜç„Çπ„Çø„Éº„Éà
        function restartGame() {
            gameState = {
                running: true,
                score1: 0,
                score2: 0,
                winScore: 3
            };
            particles.length = 0;

            // „Éè„Ç§„Éë„ÉºÁä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà
            paddle1.hyperState = 'available';
            paddle2.hyperState = 'available';
            paddle1.isDestroyed = false;
            paddle2.isDestroyed = false;
            paddle1.radius = paddle1.baseRadius;
            paddle2.radius = paddle2.baseRadius;

            resetPuck();
            updateScore();
            updateHyperUI();
            document.getElementById('gameOver').classList.remove('show');
        }

        // „Çø„ÉÉ„ÉÅ„Ç§„Éô„É≥„ÉàÂá¶ÁêÜ
        function getTouchPos(touch) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
        }

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            for (let touch of e.changedTouches) {
                const pos = getTouchPos(touch);

                // Player 1„ÅÆ„Ç®„É™„Ç¢Ôºà‰∏ãÂçäÂàÜÔºâ
                if (pos.y > canvas.height / 2) {
                    if (Math.hypot(pos.x - paddle1.x, pos.y - paddle1.y) < paddle1.radius * 2) {
                        paddle1.isDragging = true;
                        paddle1.touchId = touch.identifier;
                        // „Éà„É™„Éó„É´„Çø„ÉÉ„ÉóÊ§úÂá∫
                        checkTripleTap(paddle1, 1);
                    }
                }
                // Player 2„ÅÆ„Ç®„É™„Ç¢Ôºà‰∏äÂçäÂàÜÔºâ
                else {
                    if (Math.hypot(pos.x - paddle2.x, pos.y - paddle2.y) < paddle2.radius * 2) {
                        paddle2.isDragging = true;
                        paddle2.touchId = touch.identifier;
                        // „Éà„É™„Éó„É´„Çø„ÉÉ„ÉóÊ§úÂá∫
                        checkTripleTap(paddle2, 2);
                    }
                }
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for (let touch of e.changedTouches) {
                const pos = getTouchPos(touch);

                // Player 1„ÅÆ„Éë„Éâ„É´
                if (paddle1.isDragging && paddle1.touchId === touch.identifier && !paddle1.isDestroyed) {
                    // „Ç®„É™„Ç¢Âà∂ÈôêÔºà‰∏ãÂçäÂàÜ„ÅÆ„ÅøÔºâ
                    if (pos.y > canvas.height / 2 && pos.y < canvas.height - paddle1.radius) {
                        paddle1.x = Math.max(paddle1.radius, Math.min(canvas.width - paddle1.radius, pos.x));
                        paddle1.y = pos.y;
                    }
                }

                // Player 2„ÅÆ„Éë„Éâ„É´
                if (paddle2.isDragging && paddle2.touchId === touch.identifier && !paddle2.isDestroyed) {
                    // „Ç®„É™„Ç¢Âà∂ÈôêÔºà‰∏äÂçäÂàÜ„ÅÆ„ÅøÔºâ
                    if (pos.y < canvas.height / 2 && pos.y > paddle2.radius) {
                        paddle2.x = Math.max(paddle2.radius, Math.min(canvas.width - paddle2.radius, pos.x));
                        paddle2.y = pos.y;
                    }
                }
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            for (let touch of e.changedTouches) {
                if (paddle1.touchId === touch.identifier) {
                    paddle1.isDragging = false;
                    paddle1.touchId = null;
                }
                if (paddle2.touchId === touch.identifier) {
                    paddle2.isDragging = false;
                    paddle2.touchId = null;
                }
            }
        });

        // „Éû„Ç¶„Çπ„Ç§„Éô„É≥„ÉàÔºà„Éá„Çπ„ÇØ„Éà„ÉÉ„ÉóÁî®Ôºâ
        let activeMousePaddle = null;

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (y > canvas.height / 2) {
                if (Math.hypot(x - paddle1.x, y - paddle1.y) < paddle1.radius * 2) {
                    paddle1.isDragging = true;
                    activeMousePaddle = paddle1;
                }
            } else {
                if (Math.hypot(x - paddle2.x, y - paddle2.y) < paddle2.radius * 2) {
                    paddle2.isDragging = true;
                    activeMousePaddle = paddle2;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!activeMousePaddle || !activeMousePaddle.isDragging) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (activeMousePaddle === paddle1 && y > canvas.height / 2 && y < canvas.height - paddle1.radius) {
                paddle1.x = Math.max(paddle1.radius, Math.min(canvas.width - paddle1.radius, x));
                paddle1.y = y;
            } else if (activeMousePaddle === paddle2 && y < canvas.height / 2 && y > paddle2.radius) {
                paddle2.x = Math.max(paddle2.radius, Math.min(canvas.width - paddle2.radius, x));
                paddle2.y = y;
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (activeMousePaddle) {
                activeMousePaddle.isDragging = false;
                activeMousePaddle = null;
            }
        });

        // „Ç≤„Éº„É†„É´„Éº„Éó
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawGoals();
            drawCenterLine();
            drawPuck();
            drawPaddle(paddle1, '#ff6600', '#ff0066');
            drawPaddle(paddle2, '#00ffff', '#0066ff');
            updatePuck();
            updateParticles();

            requestAnimationFrame(gameLoop);
        }

        // ÂàùÊúüÂåñ
        resetPuck();
        gameLoop();
    </script>
</body>

</html>
