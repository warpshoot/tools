<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Air Hockey</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        #gameCanvas {
            display: block;
            background: linear-gradient(180deg, #001a33 0%, #000 50%, #1a0033 100%);
            touch-action: none;
        }

        .hud {
            position: absolute;
            width: 100%;
            pointer-events: none;
        }

        .hud-top {
            top: 40px;
            transform: rotate(180deg);
        }

        .hud-bottom {
            bottom: 40px;
        }

        .score {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            font-size: 48px;
            font-weight: bold;
        }

        .score span {
            text-shadow: 0 0 20px currentColor;
        }

        .score .p1 {
            color: #ff6600;
        }

        .score .p2 {
            color: #00ffff;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            display: none;
            border: 2px solid rgba(255, 255, 255, 0.3);
            z-index: 100;
        }

        .game-over.show {
            display: block;
        }

        .game-over h2 {
            font-size: 36px;
            margin-bottom: 16px;
            text-shadow: 0 0 20px currentColor;
        }

        .game-over p {
            font-size: 20px;
            margin-bottom: 24px;
            opacity: 0.8;
        }

        .restart-btn {
            background: linear-gradient(90deg, #ff0066, #ff6600);
            color: #fff;
            border: none;
            padding: 16px 32px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            pointer-events: auto;
        }

        .restart-btn:active {
            opacity: 0.8;
        }

        .instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            opacity: 0;
            animation: fadeOut 4s forwards;
        }

        @keyframes fadeOut {
            0%, 60% {
                opacity: 1;
            }
            100% {
                opacity: 0;
            }
        }

        .instructions h3 {
            font-size: 24px;
            margin-bottom: 12px;
        }

        .instructions p {
            font-size: 16px;
            opacity: 0.8;
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>

    <div class="hud hud-top">
        <div class="score">
            <span class="p2" id="score2">0</span>
        </div>
    </div>

    <div class="hud hud-bottom">
        <div class="score">
            <span class="p1" id="score1">0</span>
        </div>
    </div>

    <div class="instructions">
        <h3>ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ãƒ‘ãƒƒã‚¯ã‚’æ‰“ã¡è¿”ã›ï¼</h3>
        <p>3ç‚¹å…ˆå–ã§å‹åˆ©</p>
    </div>

    <div class="game-over" id="gameOver">
        <h2 id="winnerText">Player 1 WIN!</h2>
        <p>ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼</p>
        <button class="restart-btn" onclick="restartGame()">ã‚‚ã†ä¸€åº¦</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // èª¿æ•´å¯èƒ½ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
        const PHYSICS = {
            puckFriction: 0.99,        // ãƒ‘ãƒƒã‚¯ã®æ‘©æ“¦ï¼ˆ0.99 = ã‚ˆãæ»‘ã‚‹ï¼‰
            puckMaxSpeed: 15,          // ãƒ‘ãƒƒã‚¯ã®æœ€å¤§é€Ÿåº¦
            paddleSpeedMultiplier: 1.5 // ãƒ‘ãƒ‰ãƒ«ã®é€Ÿåº¦ãŒãƒ‘ãƒƒã‚¯ã«ä¸ãˆã‚‹å½±éŸ¿
        };

        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºè¨­å®š
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // ãƒªã‚µã‚¤ã‚ºæ™‚ã«ã‚²ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½ç½®ã‚’èª¿æ•´
            if (puck) {
                puck.x = canvas.width / 2;
                puck.y = canvas.height / 2;
            }
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
        let gameState = {
            running: true,
            score1: 0,
            score2: 0,
            winScore: 3
        };

        // ãƒ‘ãƒƒã‚¯
        let puck = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            vx: 0,
            vy: 0,
            radius: 15,
            trail: [] // è»Œè·¡ç”¨
        };

        // ãƒ‘ãƒ‰ãƒ«
        let paddle1 = {
            x: canvas.width / 2,
            y: canvas.height - 100,
            prevX: canvas.width / 2,
            prevY: canvas.height - 100,
            radius: 35,
            isDragging: false,
            touchId: null
        };

        let paddle2 = {
            x: canvas.width / 2,
            y: 100,
            prevX: canvas.width / 2,
            prevY: 100,
            radius: 35,
            isDragging: false,
            touchId: null
        };

        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
        const particles = [];

        // ã‚´ãƒ¼ãƒ«æç”»
        function drawGoals() {
            const goalWidth = 200;
            const goalX = (canvas.width - goalWidth) / 2;

            // Player 1ã®ã‚´ãƒ¼ãƒ«ï¼ˆä¸‹ï¼‰
            ctx.strokeStyle = '#ff6600';
            ctx.lineWidth = 8;
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ff6600';
            ctx.beginPath();
            ctx.moveTo(goalX, canvas.height - 5);
            ctx.lineTo(goalX + goalWidth, canvas.height - 5);
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Player 2ã®ã‚´ãƒ¼ãƒ«ï¼ˆä¸Šï¼‰
            ctx.strokeStyle = '#00ffff';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#00ffff';
            ctx.beginPath();
            ctx.moveTo(goalX, 5);
            ctx.lineTo(goalX + goalWidth, 5);
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        // ä¸­å¤®ç·šæç”»
        function drawCenterLine() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 10]);
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2);
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // ãƒ‘ãƒƒã‚¯æç”»
        function drawPuck() {
            // è»Œè·¡
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < puck.trail.length; i++) {
                const point = puck.trail[i];
                if (i === 0) {
                    ctx.moveTo(point.x, point.y);
                } else {
                    ctx.lineTo(point.x, point.y);
                }
            }
            ctx.stroke();

            // ãƒ‘ãƒƒã‚¯æœ¬ä½“
            const gradient = ctx.createRadialGradient(puck.x, puck.y, 0, puck.x, puck.y, puck.radius);
            gradient.addColorStop(0, '#fff');
            gradient.addColorStop(0.5, '#ffff00');
            gradient.addColorStop(1, '#ff6600');

            ctx.beginPath();
            ctx.arc(puck.x, puck.y, puck.radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.shadowBlur = 25;
            ctx.shadowColor = '#ffff00';
            ctx.fill();
            ctx.shadowBlur = 0;

            // ãƒã‚¤ãƒ©ã‚¤ãƒˆ
            ctx.beginPath();
            ctx.arc(puck.x - 5, puck.y - 5, 5, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fill();
        }

        // ãƒ‘ãƒ‰ãƒ«æç”»
        function drawPaddle(paddle, color1, color2) {
            const gradient = ctx.createRadialGradient(paddle.x, paddle.y, 0, paddle.x, paddle.y, paddle.radius);
            gradient.addColorStop(0, color1);
            gradient.addColorStop(1, color2);

            ctx.beginPath();
            ctx.arc(paddle.x, paddle.y, paddle.radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.globalAlpha = 0.6;
            ctx.shadowBlur = 20;
            ctx.shadowColor = color1;
            ctx.fill();
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;

            // å¤–æ 
            ctx.beginPath();
            ctx.arc(paddle.x, paddle.y, paddle.radius, 0, Math.PI * 2);
            ctx.strokeStyle = color1;
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        // è¡çªåˆ¤å®š
        function checkCollision(obj1, obj2) {
            const dx = obj1.x - obj2.x;
            const dy = obj1.y - obj2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < obj1.radius + obj2.radius;
        }

        // ãƒ‘ãƒ‰ãƒ«ã¨ãƒ‘ãƒƒã‚¯ã®è¡çªå‡¦ç†
        function handlePaddleCollision(paddle) {
            if (checkCollision(puck, paddle)) {
                // è¡çªæ–¹å‘
                const dx = puck.x - paddle.x;
                const dy = puck.y - paddle.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // æ­£è¦åŒ–
                const nx = dx / distance;
                const ny = dy / distance;

                // ãƒ‘ãƒ‰ãƒ«ã®é€Ÿåº¦ã‚’è¨ˆç®—
                const paddleVx = paddle.x - paddle.prevX;
                const paddleVy = paddle.y - paddle.prevY;

                // åå°„ãƒ™ã‚¯ãƒˆãƒ«
                const dotProduct = puck.vx * nx + puck.vy * ny;
                puck.vx = puck.vx - 2 * dotProduct * nx;
                puck.vy = puck.vy - 2 * dotProduct * ny;

                // ãƒ‘ãƒ‰ãƒ«ã®é€Ÿåº¦ã‚’åŠ ç®—
                puck.vx += paddleVx * PHYSICS.paddleSpeedMultiplier;
                puck.vy += paddleVy * PHYSICS.paddleSpeedMultiplier;

                // æœ€å¤§é€Ÿåº¦åˆ¶é™
                const speed = Math.sqrt(puck.vx * puck.vx + puck.vy * puck.vy);
                if (speed > PHYSICS.puckMaxSpeed) {
                    puck.vx = (puck.vx / speed) * PHYSICS.puckMaxSpeed;
                    puck.vy = (puck.vy / speed) * PHYSICS.puckMaxSpeed;
                }

                // ãƒ‘ãƒƒã‚¯ã‚’æŠ¼ã—å‡ºã™
                const overlap = puck.radius + paddle.radius - distance;
                puck.x += nx * overlap;
                puck.y += ny * overlap;

                // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                createHitEffect(puck.x, puck.y);
            }
        }

        // ãƒ’ãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        function createHitEffect(x, y) {
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    life: 1,
                    color: '#ffff00'
                });
            }
        }

        // ã‚´ãƒ¼ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        function createGoalEffect(y) {
            for (let i = 0; i < 50; i++) {
                particles.push({
                    x: canvas.width / 2 + (Math.random() - 0.5) * 200,
                    y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1,
                    color: y < canvas.height / 2 ? '#00ffff' : '#ff6600'
                });
            }
        }

        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02;

                if (p.life > 0) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    ctx.fillStyle = p.color.replace(')', `, ${p.life})`).replace('rgb', 'rgba');
                    ctx.fill();
                } else {
                    particles.splice(i, 1);
                }
            }
        }

        // ãƒ‘ãƒƒã‚¯æ›´æ–°
        function updatePuck() {
            if (!gameState.running) return;

            // ãƒ‘ãƒ‰ãƒ«ã®å‰å›ä½ç½®ã‚’æ›´æ–°
            paddle1.prevX = paddle1.x;
            paddle1.prevY = paddle1.y;
            paddle2.prevX = paddle2.x;
            paddle2.prevY = paddle2.y;

            // ãƒ‘ãƒƒã‚¯ã®ä½ç½®æ›´æ–°
            puck.x += puck.vx;
            puck.y += puck.vy;

            // æ‘©æ“¦
            puck.vx *= PHYSICS.puckFriction;
            puck.vy *= PHYSICS.puckFriction;

            // è»Œè·¡ã‚’è¿½åŠ 
            puck.trail.push({ x: puck.x, y: puck.y });
            if (puck.trail.length > 15) {
                puck.trail.shift();
            }

            // å£ã¨ã®è¡çªï¼ˆå·¦å³ï¼‰
            if (puck.x - puck.radius < 0) {
                puck.x = puck.radius;
                puck.vx = -puck.vx * 0.8;
            }
            if (puck.x + puck.radius > canvas.width) {
                puck.x = canvas.width - puck.radius;
                puck.vx = -puck.vx * 0.8;
            }

            // ã‚´ãƒ¼ãƒ«åˆ¤å®š
            const goalWidth = 200;
            const goalX = (canvas.width - goalWidth) / 2;

            // Player 2ã®ã‚´ãƒ¼ãƒ«ï¼ˆä¸Šï¼‰
            if (puck.y - puck.radius < 0) {
                if (puck.x > goalX && puck.x < goalX + goalWidth) {
                    // ã‚´ãƒ¼ãƒ«ï¼
                    gameState.score1++;
                    updateScore();
                    createGoalEffect(puck.y);
                    resetPuck();
                } else {
                    puck.y = puck.radius;
                    puck.vy = -puck.vy * 0.8;
                }
            }

            // Player 1ã®ã‚´ãƒ¼ãƒ«ï¼ˆä¸‹ï¼‰
            if (puck.y + puck.radius > canvas.height) {
                if (puck.x > goalX && puck.x < goalX + goalWidth) {
                    // ã‚´ãƒ¼ãƒ«ï¼
                    gameState.score2++;
                    updateScore();
                    createGoalEffect(puck.y);
                    resetPuck();
                } else {
                    puck.y = canvas.height - puck.radius;
                    puck.vy = -puck.vy * 0.8;
                }
            }

            // ãƒ‘ãƒ‰ãƒ«ã¨ã®è¡çª
            handlePaddleCollision(paddle1);
            handlePaddleCollision(paddle2);
        }

        // ãƒ‘ãƒƒã‚¯ãƒªã‚»ãƒƒãƒˆ
        function resetPuck() {
            puck.x = canvas.width / 2;
            puck.y = canvas.height / 2;
            puck.vx = (Math.random() - 0.5) * 6;
            puck.vy = (Math.random() - 0.5) * 6;
            puck.trail = [];
        }

        // ã‚¹ã‚³ã‚¢æ›´æ–°
        function updateScore() {
            document.getElementById('score1').textContent = gameState.score1;
            document.getElementById('score2').textContent = gameState.score2;

            if (gameState.score1 >= gameState.winScore || gameState.score2 >= gameState.winScore) {
                endGame();
            }
        }

        // ã‚²ãƒ¼ãƒ çµ‚äº†
        function endGame() {
            gameState.running = false;
            const gameOver = document.getElementById('gameOver');
            const winnerText = document.getElementById('winnerText');

            if (gameState.score1 >= gameState.winScore) {
                winnerText.textContent = 'Player 1 WIN! ğŸ†';
                winnerText.style.color = '#ff6600';
            } else {
                winnerText.textContent = 'Player 2 WIN! ğŸ†';
                winnerText.style.color = '#00ffff';
            }

            gameOver.classList.add('show');
        }

        // ã‚²ãƒ¼ãƒ å†ã‚¹ã‚¿ãƒ¼ãƒˆ
        function restartGame() {
            gameState = {
                running: true,
                score1: 0,
                score2: 0,
                winScore: 3
            };
            particles.length = 0;
            resetPuck();
            updateScore();
            document.getElementById('gameOver').classList.remove('show');
        }

        // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†
        function getTouchPos(touch) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
        }

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            for (let touch of e.changedTouches) {
                const pos = getTouchPos(touch);

                // Player 1ã®ã‚¨ãƒªã‚¢ï¼ˆä¸‹åŠåˆ†ï¼‰
                if (pos.y > canvas.height / 2) {
                    if (Math.hypot(pos.x - paddle1.x, pos.y - paddle1.y) < paddle1.radius * 2) {
                        paddle1.isDragging = true;
                        paddle1.touchId = touch.identifier;
                    }
                }
                // Player 2ã®ã‚¨ãƒªã‚¢ï¼ˆä¸ŠåŠåˆ†ï¼‰
                else {
                    if (Math.hypot(pos.x - paddle2.x, pos.y - paddle2.y) < paddle2.radius * 2) {
                        paddle2.isDragging = true;
                        paddle2.touchId = touch.identifier;
                    }
                }
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for (let touch of e.changedTouches) {
                const pos = getTouchPos(touch);

                // Player 1ã®ãƒ‘ãƒ‰ãƒ«
                if (paddle1.isDragging && paddle1.touchId === touch.identifier) {
                    // ã‚¨ãƒªã‚¢åˆ¶é™ï¼ˆä¸‹åŠåˆ†ã®ã¿ï¼‰
                    if (pos.y > canvas.height / 2 && pos.y < canvas.height - paddle1.radius) {
                        paddle1.x = Math.max(paddle1.radius, Math.min(canvas.width - paddle1.radius, pos.x));
                        paddle1.y = pos.y;
                    }
                }

                // Player 2ã®ãƒ‘ãƒ‰ãƒ«
                if (paddle2.isDragging && paddle2.touchId === touch.identifier) {
                    // ã‚¨ãƒªã‚¢åˆ¶é™ï¼ˆä¸ŠåŠåˆ†ã®ã¿ï¼‰
                    if (pos.y < canvas.height / 2 && pos.y > paddle2.radius) {
                        paddle2.x = Math.max(paddle2.radius, Math.min(canvas.width - paddle2.radius, pos.x));
                        paddle2.y = pos.y;
                    }
                }
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            for (let touch of e.changedTouches) {
                if (paddle1.touchId === touch.identifier) {
                    paddle1.isDragging = false;
                    paddle1.touchId = null;
                }
                if (paddle2.touchId === touch.identifier) {
                    paddle2.isDragging = false;
                    paddle2.touchId = null;
                }
            }
        });

        // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ç”¨ï¼‰
        let activeMousePaddle = null;

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (y > canvas.height / 2) {
                if (Math.hypot(x - paddle1.x, y - paddle1.y) < paddle1.radius * 2) {
                    paddle1.isDragging = true;
                    activeMousePaddle = paddle1;
                }
            } else {
                if (Math.hypot(x - paddle2.x, y - paddle2.y) < paddle2.radius * 2) {
                    paddle2.isDragging = true;
                    activeMousePaddle = paddle2;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!activeMousePaddle || !activeMousePaddle.isDragging) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (activeMousePaddle === paddle1 && y > canvas.height / 2 && y < canvas.height - paddle1.radius) {
                paddle1.x = Math.max(paddle1.radius, Math.min(canvas.width - paddle1.radius, x));
                paddle1.y = y;
            } else if (activeMousePaddle === paddle2 && y < canvas.height / 2 && y > paddle2.radius) {
                paddle2.x = Math.max(paddle2.radius, Math.min(canvas.width - paddle2.radius, x));
                paddle2.y = y;
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (activeMousePaddle) {
                activeMousePaddle.isDragging = false;
                activeMousePaddle = null;
            }
        });

        // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawGoals();
            drawCenterLine();
            drawPuck();
            drawPaddle(paddle1, '#ff6600', '#ff0066');
            drawPaddle(paddle2, '#00ffff', '#0066ff');
            updatePuck();
            updateParticles();

            requestAnimationFrame(gameLoop);
        }

        // åˆæœŸåŒ–
        resetPuck();
        gameLoop();
    </script>
</body>

</html>
