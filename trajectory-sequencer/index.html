<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ËªåË∑°ÊèèÁîªÂûã„Ç∑„Éº„Ç±„É≥„Çµ„Éº - Trajectory Sequencer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1280px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #2d3748;
            font-size: 32px;
            font-weight: 700;
        }

        .subtitle {
            text-align: center;
            color: #718096;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            padding: 20px;
            background: #f7fafc;
            border-radius: 12px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        button {
            padding: 10px 24px;
            font-size: 14px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            background: #4299e1;
            color: white;
        }

        button:hover {
            background: #3182ce;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(66, 153, 225, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.danger {
            background: #f56565;
        }

        button.danger:hover {
            background: #e53e3e;
            box-shadow: 0 4px 12px rgba(245, 101, 101, 0.4);
        }

        button.tool-btn {
            background: #48bb78;
        }

        button.tool-btn:hover {
            background: #38a169;
        }

        button.tool-btn.active {
            background: #2f855a;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            width: 150px;
            cursor: pointer;
        }

        .speed-label {
            font-size: 14px;
            font-weight: 600;
            min-width: 80px;
            color: #4a5568;
        }

        .color-palette {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .color-label {
            font-size: 14px;
            font-weight: 600;
            color: #4a5568;
        }

        .color-btn {
            width: 50px;
            height: 50px;
            border-radius: 10px;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .color-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .color-btn.active {
            border-color: #2d3748;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #2d3748;
            transform: scale(1.15);
        }

        .color-btn.red { background: linear-gradient(135deg, #fc5c65, #fd7984); }
        .color-btn.blue { background: linear-gradient(135deg, #45aaf2, #4b7bec); }
        .color-btn.green { background: linear-gradient(135deg, #26de81, #20bf6b); }
        .color-btn.yellow { background: linear-gradient(135deg, #fed330, #f7b731); }

        .color-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .color-clear-btn {
            padding: 2px 8px;
            font-size: 10px;
            background: #e53e3e;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-clear-btn:hover {
            background: #c53030;
            transform: scale(1.05);
        }

        .color-info {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #718096;
            white-space: nowrap;
        }

        .timbre-select {
            padding: 2px 4px;
            font-size: 10px;
            border: 1px solid #cbd5e0;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            min-width: 80px;
        }

        .canvas-container {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .canvas-wrapper {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.1);
            background: linear-gradient(to bottom, #f8f9fa, #e9ecef);
        }

        canvas {
            display: block;
            width: 100%;
            cursor: crosshair;
        }

        canvas.eraser {
            cursor: cell;
        }

        .playback-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 3px;
            height: 100%;
            background: rgba(255, 0, 0, 0.7);
            pointer-events: none;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.6);
            display: none;
        }

        .dj-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 10;
        }

        .dj-overlay div {
            margin: 2px 0;
        }

        .dj-overlay .param-label {
            color: #aaa;
            display: inline-block;
            width: 70px;
        }

        .dj-overlay .param-value {
            color: #0ff;
            font-weight: bold;
        }

        @media (max-width: 800px) {
            .container {
                padding: 15px;
            }

            h1 {
                font-size: 24px;
            }

            .controls {
                gap: 10px;
                padding: 15px;
            }

            button {
                padding: 8px 16px;
                font-size: 12px;
            }

            .slider-group {
                width: 100%;
            }

            input[type="range"] {
                flex: 1;
            }

            .color-btn {
                width: 40px;
                height: 40px;
            }
        }

        .instructions {
            text-align: center;
            color: #718096;
            font-size: 12px;
            margin-top: 20px;
            padding: 15px;
            background: #f7fafc;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ ËªåË∑°ÊèèÁîªÂûã„Ç∑„Éº„Ç±„É≥„Çµ„Éº</h1>
        <p class="subtitle">Draw colorful lines to create music - Ëâ≤„ÅßÁ∑ö„ÇíÊèè„ÅÑ„Å¶Èü≥Ê•Ω„Çí‰Ωú„Çç„ÅÜ</p>

        <div class="controls">
            <div class="control-group">
                <button id="playBtn">‚ñ∂ ÂÜçÁîü</button>
                <button id="stopBtn">‚ñ† ÂÅúÊ≠¢</button>
            </div>

            <div class="control-group">
                <label style="display: flex; align-items: center; gap: 5px; font-size: 14px; font-weight: 600; color: #4a5568; cursor: pointer;">
                    <input type="checkbox" id="pingPongCheck" style="cursor: pointer;">
                    <span>ÂæÄÂæ©ÂÜçÁîü</span>
                </label>
            </div>

            <div class="slider-group">
                <label class="speed-label">ÈÄüÂ∫¶: <span id="speedValue">1.0</span>x</label>
                <input type="range" id="speedSlider" min="0.5" max="2" step="0.1" value="1">
            </div>

            <div class="control-group">
                <button id="penBtn" class="tool-btn active">‚úèÔ∏è „Éö„É≥</button>
                <button id="eraserBtn" class="tool-btn">üßπ Ê∂à„Åó„Ç¥„É†</button>
            </div>

            <div class="control-group">
                <label class="speed-label">Èü≥Èöé:</label>
                <select id="scaleSelect">
                    <option value="pentatonic">„Éö„É≥„Çø„Éà„Éã„ÉÉ„ÇØ (Â§±Êïó„Å™„Åó)</option>
                    <option value="major">„É°„Ç∏„É£„Éº (Êòé„Çã„ÅÑ)</option>
                    <option value="minor">„Éû„Ç§„Éä„Éº (Êöó„ÅÑ)</option>
                    <option value="blues">„Éñ„É´„Éº„Çπ (Ê∏ã„ÅÑ)</option>
                    <option value="wholetone">ÂÖ®Èü≥Èöé (ÊµÆÈÅäÊÑü)</option>
                    <option value="chromatic">ÂçäÈü≥Èöé (ÂÖ®Èü≥)</option>
                </select>
            </div>

            <button id="clearAllBtn" class="danger">üóëÔ∏è „ÇØ„É™„Ç¢</button>
        </div>

        <div class="controls">
            <div class="color-palette">
                <span class="color-label">„Éö„É≥„ÅÆËâ≤:</span>
                <div class="color-group">
                    <button class="color-btn red active" data-color="red">
                    </button>
                    <select class="timbre-select" data-timbre-for="red">
                        <option value="square">Square</option>
                        <option value="triangle">Triangle</option>
                        <option value="sawtooth">Sawtooth</option>
                        <option value="sine">Sine</option>
                        <option value="piano">Piano</option>
                        <option value="bell">Bell</option>
                        <option value="bass">Bass</option>
                        <option value="strings">Strings</option>
                    </select>
                    <button class="color-clear-btn" data-clear-color="red">√ó</button>
                </div>
                <div class="color-group">
                    <button class="color-btn blue" data-color="blue">
                    </button>
                    <select class="timbre-select" data-timbre-for="blue">
                        <option value="square">Square</option>
                        <option value="triangle" selected>Triangle</option>
                        <option value="sawtooth">Sawtooth</option>
                        <option value="sine">Sine</option>
                        <option value="piano">Piano</option>
                        <option value="bell">Bell</option>
                        <option value="bass">Bass</option>
                        <option value="strings">Strings</option>
                    </select>
                    <button class="color-clear-btn" data-clear-color="blue">√ó</button>
                </div>
                <div class="color-group">
                    <button class="color-btn green" data-color="green">
                    </button>
                    <select class="timbre-select" data-timbre-for="green">
                        <option value="square">Square</option>
                        <option value="triangle">Triangle</option>
                        <option value="sawtooth" selected>Sawtooth</option>
                        <option value="sine">Sine</option>
                        <option value="piano">Piano</option>
                        <option value="bell">Bell</option>
                        <option value="bass">Bass</option>
                        <option value="strings">Strings</option>
                    </select>
                    <button class="color-clear-btn" data-clear-color="green">√ó</button>
                </div>
                <div class="color-group">
                    <button class="color-btn yellow" data-color="yellow">
                    </button>
                    <select class="timbre-select" data-timbre-for="yellow">
                        <option value="square">Square</option>
                        <option value="triangle">Triangle</option>
                        <option value="sawtooth">Sawtooth</option>
                        <option value="sine" selected>Sine</option>
                        <option value="piano">Piano</option>
                        <option value="bell">Bell</option>
                        <option value="bass">Bass</option>
                        <option value="strings">Strings</option>
                    </select>
                    <button class="color-clear-btn" data-clear-color="yellow">√ó</button>
                </div>
            </div>
        </div>

        <div class="canvas-container">
            <div class="canvas-wrapper">
                <canvas id="mainCanvas" width="1200" height="400"></canvas>
                <div class="playback-line" id="playbackLine"></div>
                <div class="dj-overlay" id="djOverlay">
                    <div><span class="param-label">Filter:</span><span class="param-value" id="pitchValue">10kHz</span></div>
                    <div><span class="param-label">Resonance:</span><span class="param-value" id="filterValue">0.5</span></div>
                </div>
            </div>
        </div>

        <div class="instructions">
            üí° ‰Ωø„ÅÑÊñπ: Ëâ≤„ÇíÈÅ∏„Çì„ÅßÁ∑ö„ÇíÊèè„Åç„ÄÅÂÜçÁîü„Éú„Çø„É≥„ÇíÊäº„Åô„Å®Èü≥„ÅåÈ≥¥„Çä„Åæ„Åô„ÄÇ<br>
            Á∏¶„ÅÆ‰ΩçÁΩÆ„ÅßÈü≥Á®ã„ÅåÂ§â„Çè„Çä„ÄÅ‰∏ä„ÅåÈ´òÈü≥„ÄÅ‰∏ã„Åå‰ΩéÈü≥„Åß„Åô„ÄÇËâ≤„Å´„Çà„Å£„Å¶Èü≥Ëâ≤„ÅåÂ§â„Çè„Çä„Åæ„Åô„ÄÇ<br>
            üéº Èü≥Èöé„ÇíÈÅ∏„Çì„ÅßÈõ∞Âõ≤Ê∞ó„ÇíÂ§â„Åà„Çâ„Çå„Åæ„Åô„ÄÇ„É™„Ç∫„É†„ÅØËá™ÂãïÊï¥Âàó„Åß„ÄÅÈÅ©ÂΩì„Å´Êèè„ÅÑ„Å¶„ÇÇÈü≥Ê•Ω„Å´„Å™„Çä„Åæ„ÅôÔºÅ<br>
            üéß <strong>DJ„É¢„Éº„Éâ:</strong> ÂÜçÁîü‰∏≠„Å´„Ç≠„É£„É≥„Éê„Çπ„Çí„Éâ„É©„ÉÉ„Ç∞ÔºÅ <strong>‰∏ä‰∏ã=„Éï„Ç£„É´„Çø„Éº</strong>„ÄÅ<strong>Â∑¶Âè≥=„É¨„Çæ„Éä„É≥„Çπ</strong>„Åß„Ç¨„Çµ„Ç¨„Çµ„Éé„Ç§„Ç∏„Éº„Å™Èü≥„ÇÇËá™Âú®„Å´Êìç‰ΩúÔºÅ
        </div>
    </div>

    <script>
        // ==================== Global State ====================
        const state = {
            isPlaying: false,
            playbackPosition: 0,
            speed: 1.0,
            tool: 'pen',
            currentColor: 'red',
            currentTimbre: 'square',
            animationId: null,
            lastTime: 0,
            audioContext: null,
            lastPlaybackX: -10,
            canvasSnapshot: null,
            activeFlashes: [],
            playedGrids: new Set(), // Track which grid positions have played
            colorTimbres: {
                red: 'square',
                blue: 'triangle',
                green: 'sawtooth',
                yellow: 'sine'
            },
            playbackDirection: 1, // 1 = right, -1 = left
            pingPongMode: false, // true = ping-pong, false = loop
            // DJ Mode (real-time effects)
            djMode: {
                active: false,
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                filterEnabled: false,
                filterCutoff: 10000,   // 200 ~ 20000 Hz
                resonance: 0.5         // 0.5 ~ 50 (Q value, start at minimum)
            }
        };

        // Musical quantization grid (16th notes at 120 BPM)
        // 5 seconds = 10 beats = 40 sixteenth notes
        // 1200px / 40 = 30px per 16th note
        const GRID_SIZE = 30;

        // Color to actual RGB values for drawing
        const COLOR_MAP = {
            red: '#fc5c65',
            blue: '#45aaf2',
            green: '#26de81',
            yellow: '#fed330'
        };

        // Canvas and context
        let canvas, ctx, playbackLine;

        // Musical Scales - different options for different moods
        const SCALES = {
            pentatonic: [
                // C Major Pentatonic: No bad notes, always harmonious
                261.63, 293.66, 329.63, 392.00, 440.00,
                523.25, 587.33, 659.25, 783.99, 880.00, 1046.50
            ],
            major: [
                // C Major: Classic, bright and happy
                261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88,
                523.25, 587.33, 659.25, 698.46, 783.99, 880.00, 987.77, 1046.50
            ],
            minor: [
                // C Natural Minor: Darker, more emotional
                261.63, 293.66, 311.13, 349.23, 392.00, 415.30, 466.16,
                523.25, 587.33, 622.25, 698.46, 783.99, 830.61, 932.33, 1046.50
            ],
            blues: [
                // C Blues Scale: Soulful and groovy
                261.63, 311.13, 349.23, 369.99, 392.00, 466.16,
                523.25, 622.25, 698.46, 739.99, 783.99, 932.33, 1046.50
            ],
            wholetone: [
                // C Whole Tone: Dreamy, floating feeling
                261.63, 293.66, 329.63, 369.99, 415.30, 466.16,
                523.25, 587.33, 659.25, 739.99, 830.61, 932.33, 1046.50
            ],
            chromatic: [
                // Chromatic: All notes available
                261.63, 277.18, 293.66, 311.13, 329.63, 349.23, 369.99, 392.00,
                415.30, 440.00, 466.16, 493.88, 523.25, 554.37, 587.33, 622.25,
                659.25, 698.46, 739.99, 783.99, 830.61, 880.00, 932.33, 987.77, 1046.50
            ]
        };

        // Current active scale
        let currentScale = SCALES.pentatonic;

        // ==================== Audio Setup ====================
        async function initAudio() {
            if (!state.audioContext) {
                state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            // Resume context if suspended (required by modern browsers, especially Chrome)
            if (state.audioContext.state === 'suspended') {
                try {
                    await state.audioContext.resume();
                    console.log('AudioContext resumed, state:', state.audioContext.state);
                } catch (error) {
                    console.error('Failed to resume AudioContext:', error);
                }
            }

            // Wait a bit to ensure context is fully running
            if (state.audioContext.state !== 'running') {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }

        function yToFrequency(y, canvasHeight) {
            const index = Math.floor((1 - y / canvasHeight) * currentScale.length);
            return currentScale[Math.max(0, Math.min(currentScale.length - 1, index))];
        }

        async function playNote(frequency, timbre, duration = 0.25) {
            const ctx = state.audioContext;
            if (!ctx) return;

            // Ensure audio context is running (important for Chrome)
            if (ctx.state === 'suspended') {
                await ctx.resume();
            }

            // Double-check the context is running
            if (ctx.state !== 'running') {
                console.warn('AudioContext not running:', ctx.state);
                return;
            }

            const now = ctx.currentTime;

            // Basic waveforms
            if (['square', 'triangle', 'sawtooth', 'sine'].includes(timbre)) {
                const oscillator = ctx.createOscillator();
                const gainNode = ctx.createGain();

                oscillator.type = timbre;
                oscillator.frequency.setValueAtTime(frequency, now);

                // ADSR Envelope - softer and more musical
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(0.2, now + 0.02); // Attack
                gainNode.gain.linearRampToValueAtTime(0.12, now + 0.08); // Decay to Sustain
                gainNode.gain.setValueAtTime(0.12, now + duration - 0.15); // Sustain
                gainNode.gain.linearRampToValueAtTime(0, now + duration); // Release

                // Apply DJ Mode filter if active
                if (state.djMode.filterEnabled) {
                    const filter = ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(state.djMode.filterCutoff, now);
                    filter.Q.setValueAtTime(state.djMode.resonance, now);

                    oscillator.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(ctx.destination);
                } else {
                    oscillator.connect(gainNode);
                    gainNode.connect(ctx.destination);
                }

                oscillator.start(now);
                oscillator.stop(now + duration);
            }
            // Piano - multiple sine waves (harmonics)
            else if (timbre === 'piano') {
                const harmonics = [1, 2, 3, 4];
                const gains = [0.3, 0.15, 0.1, 0.05];

                harmonics.forEach((harmonic, index) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();

                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(frequency * harmonic, now);

                    // Piano-like envelope: quick attack, slower decay
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(gains[index], now + 0.005);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + duration);

                    // Apply DJ Mode filter if active
                    if (state.djMode.filterEnabled) {
                        const filter = ctx.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.frequency.setValueAtTime(state.djMode.filterCutoff, now);
                        filter.Q.setValueAtTime(state.djMode.resonance, now);

                        osc.connect(filter);
                        filter.connect(gain);
                        gain.connect(ctx.destination);
                    } else {
                        osc.connect(gain);
                        gain.connect(ctx.destination);
                    }

                    osc.start(now);
                    osc.stop(now + duration);
                });
            }
            // Bell - frequency modulation
            else if (timbre === 'bell') {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(frequency, now);

                // Bell envelope: quick attack, long decay
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.3, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, now + duration * 2);

                // Apply DJ Mode filter if active
                if (state.djMode.filterEnabled) {
                    const filter = ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(state.djMode.filterCutoff, now);
                    filter.Q.setValueAtTime(state.djMode.resonance, now);

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(ctx.destination);
                } else {
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                }

                osc.start(now);
                osc.stop(now + duration * 2);
            }
            // Bass - sawtooth with low-pass filter
            else if (timbre === 'bass') {
                const osc = ctx.createOscillator();
                const filter = ctx.createBiquadFilter();
                const djFilter = state.djMode.filterEnabled ? ctx.createBiquadFilter() : null;
                const gain = ctx.createGain();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(frequency, now);

                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(800, now);
                filter.Q.setValueAtTime(5, now);

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.25, now + 0.01);
                gain.gain.linearRampToValueAtTime(0.15, now + 0.05);
                gain.gain.linearRampToValueAtTime(0, now + duration);

                // Connect: osc -> bass filter -> (optional DJ filter) -> gain -> destination
                osc.connect(filter);
                if (djFilter) {
                    djFilter.type = 'lowpass';
                    djFilter.frequency.setValueAtTime(state.djMode.filterCutoff, now);
                    djFilter.Q.setValueAtTime(state.djMode.resonance, now);

                    filter.connect(djFilter);
                    djFilter.connect(gain);
                } else {
                    filter.connect(gain);
                }
                gain.connect(ctx.destination);

                osc.start(now);
                osc.stop(now + duration);
            }
            // Strings - sawtooth with slow attack
            else if (timbre === 'strings') {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(frequency, now);

                // Strings envelope: slow attack, sustained
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.15, now + 0.1);
                gain.gain.setValueAtTime(0.15, now + duration - 0.1);
                gain.gain.linearRampToValueAtTime(0, now + duration);

                // Apply DJ Mode filter if active
                if (state.djMode.filterEnabled) {
                    const filter = ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(state.djMode.filterCutoff, now);
                    filter.Q.setValueAtTime(state.djMode.resonance, now);

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(ctx.destination);
                } else {
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                }

                osc.start(now);
                osc.stop(now + duration);
            }
        }

        // ==================== Drawing Setup ====================
        function init() {
            canvas = document.getElementById('mainCanvas');
            ctx = canvas.getContext('2d', { willReadFrequently: true });
            playbackLine = document.getElementById('playbackLine');

            drawGrid();
            setupControls();
            setupDrawing();
        }

        function drawGrid() {
            const w = canvas.width;
            const h = canvas.height;

            ctx.strokeStyle = 'rgba(0, 0, 0, 0.08)';
            ctx.lineWidth = 1;

            // Vertical lines (16 divisions)
            for (let i = 1; i < 16; i++) {
                const x = (w / 16) * i;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
            }

            // Horizontal lines (12 divisions - for 13 notes)
            for (let i = 1; i < 12; i++) {
                const y = (h / 12) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }
        }

        // ==================== Controls ====================
        function setupControls() {
            // Play/Stop
            document.getElementById('playBtn').addEventListener('click', play);
            document.getElementById('stopBtn').addEventListener('click', stop);

            // Ping-pong mode checkbox
            const pingPongCheck = document.getElementById('pingPongCheck');
            pingPongCheck.addEventListener('change', (e) => {
                state.pingPongMode = e.target.checked;
            });

            // Speed slider
            const speedSlider = document.getElementById('speedSlider');
            const speedValue = document.getElementById('speedValue');
            speedSlider.addEventListener('input', (e) => {
                state.speed = parseFloat(e.target.value);
                speedValue.textContent = state.speed.toFixed(1);
            });

            // Scale selector
            const scaleSelect = document.getElementById('scaleSelect');
            scaleSelect.addEventListener('change', (e) => {
                currentScale = SCALES[e.target.value];
                console.log('Scale changed to:', e.target.value);
            });

            // Tool buttons
            document.getElementById('penBtn').addEventListener('click', () => setTool('pen'));
            document.getElementById('eraserBtn').addEventListener('click', () => setTool('eraser'));

            // Clear all
            document.getElementById('clearAllBtn').addEventListener('click', clearAll);

            // Color palette
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.currentColor = btn.dataset.color;
                    state.currentTimbre = state.colorTimbres[btn.dataset.color];
                });
            });

            // Timbre selectors
            document.querySelectorAll('.timbre-select').forEach(select => {
                select.addEventListener('change', (e) => {
                    const color = select.dataset.timbreFor;
                    state.colorTimbres[color] = e.target.value;
                    // Update current timbre if this color is selected
                    if (state.currentColor === color) {
                        state.currentTimbre = e.target.value;
                    }
                });
            });

            // Color clear buttons
            document.querySelectorAll('.color-clear-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const color = btn.dataset.clearColor;
                    if (confirm(`${color}„ÅÆÁ∑ö„Çí„Åô„Åπ„Å¶ÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü`)) {
                        clearColor(color);
                    }
                });
            });
        }

        function setTool(tool) {
            state.tool = tool;

            const penBtn = document.getElementById('penBtn');
            const eraserBtn = document.getElementById('eraserBtn');

            if (tool === 'pen') {
                penBtn.classList.add('active');
                eraserBtn.classList.remove('active');
                canvas.classList.remove('eraser');
            } else {
                eraserBtn.classList.add('active');
                penBtn.classList.remove('active');
                canvas.classList.add('eraser');
            }
        }

        function clearAll() {
            if (confirm('„Ç≠„É£„É≥„Éê„Çπ„Çí„ÇØ„É™„Ç¢„Åó„Åæ„Åô„ÅãÔºü')) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGrid();
            }
        }

        function clearColor(color) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Get target RGB range for the color
            const colorRanges = {
                red: { rMin: 200, rMax: 255, gMin: 0, gMax: 150, bMin: 0, bMax: 150 },
                blue: { rMin: 0, rMax: 150, gMin: 150, gMax: 255, bMin: 200, bMax: 255 },
                green: { rMin: 0, rMax: 150, gMin: 200, gMax: 255, bMin: 0, bMax: 200 },
                yellow: { rMin: 200, rMax: 255, gMin: 200, gMax: 255, bMin: 0, bMax: 150 }
            };

            const range = colorRanges[color];
            if (!range) return;

            // Clear pixels matching the color
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const a = data[i + 3];

                if (a > 200 &&
                    r >= range.rMin && r <= range.rMax &&
                    g >= range.gMin && g <= range.gMax &&
                    b >= range.bMin && b <= range.bMax) {
                    // Make transparent
                    data[i + 3] = 0;
                }
            }

            ctx.putImageData(imageData, 0, 0);
            drawGrid();
        }

        // ==================== Drawing ====================
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        function setupDrawing() {
            // Mouse events on canvas
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);

            // Document-level events to handle dragging outside canvas
            document.addEventListener('mousemove', draw);
            document.addEventListener('mouseup', stopDrawing);

            // Touch events
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                canvas.dispatchEvent(mouseEvent);
            });

            document.addEventListener('touchmove', (e) => {
                if (!isDrawing && !state.djMode.active) return;
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                draw(mouseEvent);
            }, { passive: false });

            document.addEventListener('touchend', (e) => {
                if (!isDrawing && !state.djMode.active) return;
                e.preventDefault();
                stopDrawing();
            }, { passive: false });
        }

        function getCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        function startDrawing(e) {
            const pos = getCoordinates(e);

            // DJ Mode: During playback, start DJ control instead of drawing
            if (state.isPlaying) {
                state.djMode.active = true;
                state.djMode.startX = pos.x;
                state.djMode.startY = pos.y;
                state.djMode.currentX = pos.x;
                state.djMode.currentY = pos.y;
                state.djMode.filterEnabled = false;
                state.djMode.filterCutoff = 10000;
                state.djMode.resonance = 0.5;

                // Show DJ overlay
                document.getElementById('djOverlay').style.display = 'block';
                updateDJVisuals();
                return;
            }

            // Normal drawing mode
            isDrawing = true;
            lastX = pos.x;
            lastY = pos.y;
        }

        function draw(e) {
            const pos = getCoordinates(e);

            // DJ Mode: Update effects based on X/Y distance from start
            if (state.djMode.active) {
                state.djMode.currentX = pos.x;
                state.djMode.currentY = pos.y;

                const deltaY = state.djMode.startY - pos.y; // Inverted: up = positive
                const deltaX = pos.x - state.djMode.startX; // Right = positive

                // Filter Cutoff (Y-axis): ¬±150px = 200Hz ~ 20kHz (more sensitive)
                // Up = bright (20kHz), Down = muffled (200Hz), Center = 10kHz
                const filterNormalized = Math.max(-1, Math.min(1, deltaY / 150)); // -1 to 1, clamped
                const logMin = Math.log(200);
                const logMax = Math.log(20000);
                const logCenter = (logMin + logMax) / 2;
                const logFilter = logCenter + filterNormalized * (logMax - logMin) / 2;
                state.djMode.filterCutoff = Math.exp(logFilter);
                state.djMode.filterCutoff = Math.max(200, Math.min(20000, state.djMode.filterCutoff));

                // Resonance (X-axis): 0 ~ 800px = 0.5 ~ 50 (Q value) - right direction only
                // Start point = clean (0.5), Right = resonant/noisy (50)
                const resonanceNormalized = Math.max(0, Math.min(1, deltaX / 800)); // 0 to 1, only right
                const logResMin = Math.log(0.5);
                const logResMax = Math.log(50);
                const logRes = logResMin + resonanceNormalized * (logResMax - logResMin);
                state.djMode.resonance = Math.exp(logRes);
                state.djMode.resonance = Math.max(0.5, Math.min(50, state.djMode.resonance));

                state.djMode.filterEnabled = true;

                // Update visual feedback
                updateDJVisuals();

                return;
            }

            // Normal drawing mode
            if (!isDrawing) return;

            if (state.tool === 'pen') {
                ctx.strokeStyle = COLOR_MAP[state.currentColor];
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
            } else if (state.tool === 'eraser') {
                const eraserSize = 30;
                ctx.clearRect(pos.x - eraserSize / 2, pos.y - eraserSize / 2, eraserSize, eraserSize);
                // Redraw grid in erased area
                ctx.save();
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.08)';
                ctx.lineWidth = 1;

                const w = canvas.width;
                const h = canvas.height;

                for (let i = 1; i < 16; i++) {
                    const x = (w / 16) * i;
                    if (x >= pos.x - eraserSize / 2 && x <= pos.x + eraserSize / 2) {
                        ctx.beginPath();
                        ctx.moveTo(x, Math.max(0, pos.y - eraserSize / 2));
                        ctx.lineTo(x, Math.min(h, pos.y + eraserSize / 2));
                        ctx.stroke();
                    }
                }

                for (let i = 1; i < 12; i++) {
                    const y = (h / 12) * i;
                    if (y >= pos.y - eraserSize / 2 && y <= pos.y + eraserSize / 2) {
                        ctx.beginPath();
                        ctx.moveTo(Math.max(0, pos.x - eraserSize / 2), y);
                        ctx.lineTo(Math.min(w, pos.x + eraserSize / 2), y);
                        ctx.stroke();
                    }
                }
                ctx.restore();
            }

            lastX = pos.x;
            lastY = pos.y;
        }

        function stopDrawing() {
            // Reset DJ Mode
            if (state.djMode.active) {
                state.djMode.active = false;
                state.djMode.filterEnabled = false;
                state.djMode.filterCutoff = 10000;
                state.djMode.resonance = 0.5;

                // Hide DJ overlay
                document.getElementById('djOverlay').style.display = 'none';
            }

            // Reset drawing mode
            if (isDrawing) {
                isDrawing = false;
            }
        }

        // ==================== DJ Mode Visuals ====================
        function updateDJVisuals() {
            // Update text display
            let filterDisplay;
            if (state.djMode.filterCutoff >= 1000) {
                filterDisplay = `${(state.djMode.filterCutoff / 1000).toFixed(1)}kHz`;
            } else {
                filterDisplay = `${Math.round(state.djMode.filterCutoff)}Hz`;
            }

            const resonanceDisplay = state.djMode.resonance.toFixed(1);

            document.getElementById('pitchValue').textContent = filterDisplay;
            document.getElementById('filterValue').textContent = resonanceDisplay;
        }

        function drawDJGuides() {
            if (!state.djMode.active || !state.canvasSnapshot) return;

            // Draw crosshair at start position
            ctx.save();
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);

            // Vertical line (filter cutoff indicator)
            ctx.beginPath();
            ctx.moveTo(state.djMode.startX, 0);
            ctx.lineTo(state.djMode.startX, canvas.height);
            ctx.stroke();

            // Horizontal line (resonance indicator)
            ctx.beginPath();
            ctx.moveTo(0, state.djMode.startY);
            ctx.lineTo(canvas.width, state.djMode.startY);
            ctx.stroke();

            ctx.setLineDash([]);

            // Draw start point marker
            ctx.fillStyle = 'rgba(0, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(state.djMode.startX, state.djMode.startY, 8, 0, Math.PI * 2);
            ctx.fill();

            // Draw current position marker
            ctx.strokeStyle = 'rgba(255, 0, 255, 1)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(state.djMode.currentX, state.djMode.currentY, 12, 0, Math.PI * 2);
            ctx.stroke();

            // Draw delta lines
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.6)';
            ctx.lineWidth = 2;

            // Vertical delta (filter cutoff)
            ctx.beginPath();
            ctx.moveTo(state.djMode.startX, state.djMode.startY);
            ctx.lineTo(state.djMode.startX, state.djMode.currentY);
            ctx.stroke();

            // Horizontal delta (resonance)
            ctx.beginPath();
            ctx.moveTo(state.djMode.startX, state.djMode.currentY);
            ctx.lineTo(state.djMode.currentX, state.djMode.currentY);
            ctx.stroke();

            ctx.restore();
        }

        // ==================== Playback ====================
        async function play() {
            if (state.isPlaying) return;

            // Initialize audio context on user interaction
            await initAudio();

            // Play a silent note to fully activate AudioContext (Chrome fix)
            if (state.audioContext && state.audioContext.state === 'running') {
                const dummyOsc = state.audioContext.createOscillator();
                const dummyGain = state.audioContext.createGain();
                dummyGain.gain.value = 0; // Silent
                dummyOsc.connect(dummyGain);
                dummyGain.connect(state.audioContext.destination);
                dummyOsc.start();
                dummyOsc.stop(state.audioContext.currentTime + 0.001);
            }

            // Save canvas state before playback
            state.canvasSnapshot = ctx.getImageData(0, 0, canvas.width, canvas.height);
            state.activeFlashes = [];
            state.playedGrids.clear();

            state.isPlaying = true;
            state.playbackPosition = 0;
            state.playbackDirection = 1; // Start going right
            state.lastTime = performance.now();
            state.lastPlaybackX = -10;

            playbackLine.style.display = 'block';

            state.animationId = requestAnimationFrame(animate);
        }

        function stop() {
            state.isPlaying = false;
            state.playbackPosition = 0;
            state.lastPlaybackX = -10;

            if (state.animationId) {
                cancelAnimationFrame(state.animationId);
                state.animationId = null;
            }

            // Restore canvas to remove flash effects
            if (state.canvasSnapshot) {
                ctx.putImageData(state.canvasSnapshot, 0, 0);
                state.canvasSnapshot = null;
            }

            playbackLine.style.display = 'none';
            playbackLine.style.left = '0%';
        }

        function animate(currentTime) {
            if (!state.isPlaying) return;

            // Handle first frame
            if (!currentTime) {
                state.animationId = requestAnimationFrame(animate);
                return;
            }

            const deltaTime = currentTime - state.lastTime;
            state.lastTime = currentTime;

            // Move playback position (1200px in 5 seconds at 1x speed)
            const baseSpeed = 1200 / (5 * 1000); // pixels per ms
            state.playbackPosition += deltaTime * baseSpeed * state.speed * state.playbackDirection;

            // Handle boundary conditions
            if (state.pingPongMode) {
                // Ping-pong mode: reverse direction at boundaries
                if (state.playbackPosition >= canvas.width) {
                    state.playbackPosition = canvas.width - 1;
                    state.playbackDirection = -1; // Go left
                    state.lastPlaybackX = canvas.width + 10;
                    state.playedGrids.clear();
                } else if (state.playbackPosition <= 0) {
                    state.playbackPosition = 0;
                    state.playbackDirection = 1; // Go right
                    state.lastPlaybackX = -10;
                    state.playedGrids.clear();
                }
            } else {
                // Loop mode: jump back to start
                if (state.playbackPosition >= canvas.width) {
                    state.playbackPosition = 0;
                    state.lastPlaybackX = -10;
                    state.activeFlashes = [];
                    state.playedGrids.clear();
                }
            }

            // Restore original canvas and redraw flashes
            if (state.canvasSnapshot) {
                ctx.putImageData(state.canvasSnapshot, 0, 0);

                // Draw DJ mode guides if active
                drawDJGuides();

                // Redraw active flashes
                state.activeFlashes.forEach(flash => {
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = flash.color;
                    ctx.globalAlpha = flash.alpha;
                    ctx.beginPath();
                    ctx.arc(flash.x, flash.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });

                // Fade out flashes
                state.activeFlashes = state.activeFlashes.map(flash => ({
                    ...flash,
                    alpha: flash.alpha * 0.9
                })).filter(flash => flash.alpha > 0.05);
            }

            // Update playback line position
            const percentage = (state.playbackPosition / canvas.width) * 100;
            playbackLine.style.left = percentage + '%';

            // Check for intersections and play notes
            checkAndPlayNotes(Math.floor(state.playbackPosition));

            state.animationId = requestAnimationFrame(animate);
        }

        function checkAndPlayNotes(x) {
            // Only check new positions (skip if we've already checked this x)
            if (state.playbackDirection === 1) {
                // Moving right: skip if x hasn't advanced
                if (x <= state.lastPlaybackX || x >= canvas.width) return;
            } else {
                // Moving left: skip if x hasn't decreased
                if (x >= state.lastPlaybackX || x < 0) return;
            }

            // Quantize to nearest grid position (16th note)
            const gridPosition = Math.round(x / GRID_SIZE) * GRID_SIZE;

            // Skip if we've already played this grid position
            if (state.playedGrids.has(gridPosition)) {
                state.lastPlaybackX = x;
                return;
            }

            // Get pixel data from the original snapshot (not the current canvas with flashes)
            if (!state.canvasSnapshot) return;

            const snapshotData = state.canvasSnapshot.data;
            const width = state.canvasSnapshot.width;

            // Check if there are any drawn pixels at this x position
            let hasDrawing = false;
            const detectedNotes = [];

            // Group y positions into buckets to avoid too many notes at once
            const yBuckets = new Map();
            const bucketSize = 30; // pixels - group nearby notes

            for (let y = 0; y < canvas.height; y++) {
                // Calculate index in the snapshot data for pixel at (x, y)
                const i = (y * width + x) * 4;
                const r = snapshotData[i];
                const g = snapshotData[i + 1];
                const b = snapshotData[i + 2];
                const a = snapshotData[i + 3];

                // Only detect fully opaque pixels (drawn lines, not grid or artifacts)
                if (a > 200) {
                    // Determine color and timbre
                    const colorInfo = getColorFromRGB(r, g, b);
                    if (colorInfo) {
                        hasDrawing = true;
                        const frequency = yToFrequency(y, canvas.height);
                        const bucket = Math.floor(y / bucketSize);
                        const key = `${colorInfo.timbre}_${bucket}`;

                        // Only play one note per bucket per color
                        if (!yBuckets.has(key)) {
                            detectedNotes.push({ frequency, timbre: colorInfo.timbre, y, color: colorInfo.color });
                            yBuckets.set(key, true);
                        }
                    }
                }
            }

            // Play notes if we detected any drawing
            if (hasDrawing && detectedNotes.length > 0) {
                detectedNotes.forEach(note => {
                    playNote(note.frequency, note.timbre);
                    flashIntersection(x, note.y, note.color);
                });
                // Mark this grid position as played
                state.playedGrids.add(gridPosition);
            }

            state.lastPlaybackX = x;
        }

        function getColorFromRGB(r, g, b) {
            // Exclude gray colors (grid lines and background)
            const maxDiff = Math.max(Math.abs(r - g), Math.abs(g - b), Math.abs(r - b));
            if (maxDiff < 50) return null; // Too close to gray

            // Match RGB to our color palette (only vibrant colors)
            let color = null;
            if (r > 200 && g < 150 && b < 150) color = 'red';
            else if (r < 150 && g > 150 && b > 200) color = 'blue';
            else if (r < 150 && g > 200 && b < 200) color = 'green';
            else if (r > 200 && g > 200 && b < 150) color = 'yellow';

            if (color) {
                return { color: color, timbre: state.colorTimbres[color] };
            }
            return null;
        }

        function flashIntersection(x, y, color) {
            // Add flash to active flashes array
            state.activeFlashes.push({
                x: x,
                y: y,
                color: COLOR_MAP[color],
                alpha: 0.8
            });
        }

        // ==================== Start Application ====================
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
