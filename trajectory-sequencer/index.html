<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ËªåË∑°ÊèèÁîªÂûã„Ç∑„Éº„Ç±„É≥„Çµ„Éº - Trajectory Sequencer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1280px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #2d3748;
            font-size: 32px;
            font-weight: 700;
        }

        .subtitle {
            text-align: center;
            color: #718096;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            padding: 20px;
            background: #f7fafc;
            border-radius: 12px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        button {
            padding: 10px 24px;
            font-size: 14px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            background: #4299e1;
            color: white;
        }

        button:hover {
            background: #3182ce;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(66, 153, 225, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.danger {
            background: #f56565;
        }

        button.danger:hover {
            background: #e53e3e;
            box-shadow: 0 4px 12px rgba(245, 101, 101, 0.4);
        }

        button.tool-btn {
            background: #48bb78;
        }

        button.tool-btn:hover {
            background: #38a169;
        }

        button.tool-btn.active {
            background: #2f855a;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            width: 150px;
            cursor: pointer;
        }

        .speed-label {
            font-size: 14px;
            font-weight: 600;
            min-width: 80px;
            color: #4a5568;
        }

        .color-palette {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .color-label {
            font-size: 14px;
            font-weight: 600;
            color: #4a5568;
        }

        .color-btn {
            width: 50px;
            height: 50px;
            border-radius: 10px;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .color-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .color-btn.active {
            border-color: #2d3748;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #2d3748;
            transform: scale(1.15);
        }

        .color-btn.red { background: linear-gradient(135deg, #fc5c65, #fd7984); }
        .color-btn.blue { background: linear-gradient(135deg, #45aaf2, #4b7bec); }
        .color-btn.green { background: linear-gradient(135deg, #26de81, #20bf6b); }
        .color-btn.yellow { background: linear-gradient(135deg, #fed330, #f7b731); }

        .color-info {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #718096;
            white-space: nowrap;
        }

        .canvas-container {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .canvas-wrapper {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.1);
            background: linear-gradient(to bottom, #f8f9fa, #e9ecef);
        }

        canvas {
            display: block;
            width: 100%;
            cursor: crosshair;
        }

        canvas.eraser {
            cursor: cell;
        }

        .playback-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 3px;
            height: 100%;
            background: rgba(255, 0, 0, 0.7);
            pointer-events: none;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.6);
            display: none;
        }

        @media (max-width: 800px) {
            .container {
                padding: 15px;
            }

            h1 {
                font-size: 24px;
            }

            .controls {
                gap: 10px;
                padding: 15px;
            }

            button {
                padding: 8px 16px;
                font-size: 12px;
            }

            .slider-group {
                width: 100%;
            }

            input[type="range"] {
                flex: 1;
            }

            .color-btn {
                width: 40px;
                height: 40px;
            }
        }

        .instructions {
            text-align: center;
            color: #718096;
            font-size: 12px;
            margin-top: 20px;
            padding: 15px;
            background: #f7fafc;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ ËªåË∑°ÊèèÁîªÂûã„Ç∑„Éº„Ç±„É≥„Çµ„Éº</h1>
        <p class="subtitle">Draw colorful lines to create music - Ëâ≤„ÅßÁ∑ö„ÇíÊèè„ÅÑ„Å¶Èü≥Ê•Ω„Çí‰Ωú„Çç„ÅÜ</p>

        <div class="controls">
            <div class="control-group">
                <button id="playBtn">‚ñ∂ ÂÜçÁîü</button>
                <button id="stopBtn">‚ñ† ÂÅúÊ≠¢</button>
            </div>

            <div class="slider-group">
                <label class="speed-label">ÈÄüÂ∫¶: <span id="speedValue">1.0</span>x</label>
                <input type="range" id="speedSlider" min="0.5" max="2" step="0.1" value="1">
            </div>

            <div class="control-group">
                <button id="penBtn" class="tool-btn active">‚úèÔ∏è „Éö„É≥</button>
                <button id="eraserBtn" class="tool-btn">üßπ Ê∂à„Åó„Ç¥„É†</button>
            </div>

            <button id="clearAllBtn" class="danger">üóëÔ∏è „ÇØ„É™„Ç¢</button>
        </div>

        <div class="controls">
            <div class="color-palette">
                <span class="color-label">„Éö„É≥„ÅÆËâ≤:</span>
                <button class="color-btn red active" data-color="red" data-timbre="square">
                    <span class="color-info">Square</span>
                </button>
                <button class="color-btn blue" data-color="blue" data-timbre="triangle">
                    <span class="color-info">Triangle</span>
                </button>
                <button class="color-btn green" data-color="green" data-timbre="sawtooth">
                    <span class="color-info">Sawtooth</span>
                </button>
                <button class="color-btn yellow" data-color="yellow" data-timbre="sine">
                    <span class="color-info">Sine</span>
                </button>
            </div>
        </div>

        <div class="canvas-container">
            <div class="canvas-wrapper">
                <canvas id="mainCanvas" width="1200" height="400"></canvas>
                <div class="playback-line" id="playbackLine"></div>
            </div>
        </div>

        <div class="instructions">
            üí° ‰Ωø„ÅÑÊñπ: Ëâ≤„ÇíÈÅ∏„Çì„ÅßÁ∑ö„ÇíÊèè„Åç„ÄÅÂÜçÁîü„Éú„Çø„É≥„ÇíÊäº„Åô„Å®Èü≥„ÅåÈ≥¥„Çä„Åæ„Åô„ÄÇ<br>
            Á∏¶„ÅÆ‰ΩçÁΩÆ„ÅßÈü≥Á®ã„ÅåÂ§â„Çè„Çä„ÄÅ‰∏ä„ÅåÈ´òÈü≥„ÄÅ‰∏ã„Åå‰ΩéÈü≥„Åß„Åô„ÄÇËâ≤„Å´„Çà„Å£„Å¶Èü≥Ëâ≤„ÅåÂ§â„Çè„Çä„Åæ„Åô„ÄÇ
        </div>
    </div>

    <script>
        // ==================== Global State ====================
        const state = {
            isPlaying: false,
            playbackPosition: 0,
            speed: 1.0,
            tool: 'pen',
            currentColor: 'red',
            currentTimbre: 'square',
            animationId: null,
            lastTime: 0,
            audioContext: null,
            lastPlaybackX: -10,
            canvasSnapshot: null,
            activeFlashes: []
        };

        // Color to actual RGB values for drawing
        const COLOR_MAP = {
            red: '#fc5c65',
            blue: '#45aaf2',
            green: '#26de81',
            yellow: '#fed330'
        };

        // Canvas and context
        let canvas, ctx, playbackLine;

        // C Major Scale: C4 to C5 (extended range)
        const SCALE = [
            261.63, 277.18, 293.66, 311.13, 329.63, 349.23, 369.99, 392.00,
            415.30, 440.00, 466.16, 493.88, 523.25
        ];

        // ==================== Audio Setup ====================
        function initAudio() {
            if (!state.audioContext) {
                state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            // Resume context if suspended (required by modern browsers)
            if (state.audioContext.state === 'suspended') {
                state.audioContext.resume();
            }
        }

        function yToFrequency(y, canvasHeight) {
            const index = Math.floor((1 - y / canvasHeight) * SCALE.length);
            return SCALE[Math.max(0, Math.min(SCALE.length - 1, index))];
        }

        function playNote(frequency, timbre, duration = 0.15) {
            const ctx = state.audioContext;
            if (!ctx) return;

            const now = ctx.currentTime;

            const oscillator = ctx.createOscillator();
            const gainNode = ctx.createGain();

            oscillator.type = timbre;
            oscillator.frequency.setValueAtTime(frequency, now);

            // ADSR Envelope
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(0.3, now + 0.01); // Attack
            gainNode.gain.linearRampToValueAtTime(0.15, now + 0.06); // Decay to Sustain
            gainNode.gain.setValueAtTime(0.15, now + duration - 0.1); // Sustain
            gainNode.gain.linearRampToValueAtTime(0, now + duration); // Release

            oscillator.connect(gainNode);
            gainNode.connect(ctx.destination);

            oscillator.start(now);
            oscillator.stop(now + duration);
        }

        // ==================== Drawing Setup ====================
        function init() {
            canvas = document.getElementById('mainCanvas');
            ctx = canvas.getContext('2d', { willReadFrequently: true });
            playbackLine = document.getElementById('playbackLine');

            drawGrid();
            setupControls();
            setupDrawing();
        }

        function drawGrid() {
            const w = canvas.width;
            const h = canvas.height;

            ctx.strokeStyle = 'rgba(0, 0, 0, 0.08)';
            ctx.lineWidth = 1;

            // Vertical lines (16 divisions)
            for (let i = 1; i < 16; i++) {
                const x = (w / 16) * i;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
            }

            // Horizontal lines (12 divisions - for 13 notes)
            for (let i = 1; i < 12; i++) {
                const y = (h / 12) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }
        }

        // ==================== Controls ====================
        function setupControls() {
            // Play/Stop
            document.getElementById('playBtn').addEventListener('click', play);
            document.getElementById('stopBtn').addEventListener('click', stop);

            // Speed slider
            const speedSlider = document.getElementById('speedSlider');
            const speedValue = document.getElementById('speedValue');
            speedSlider.addEventListener('input', (e) => {
                state.speed = parseFloat(e.target.value);
                speedValue.textContent = state.speed.toFixed(1);
            });

            // Tool buttons
            document.getElementById('penBtn').addEventListener('click', () => setTool('pen'));
            document.getElementById('eraserBtn').addEventListener('click', () => setTool('eraser'));

            // Clear all
            document.getElementById('clearAllBtn').addEventListener('click', clearAll);

            // Color palette
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.currentColor = btn.dataset.color;
                    state.currentTimbre = btn.dataset.timbre;
                });
            });
        }

        function setTool(tool) {
            state.tool = tool;

            const penBtn = document.getElementById('penBtn');
            const eraserBtn = document.getElementById('eraserBtn');

            if (tool === 'pen') {
                penBtn.classList.add('active');
                eraserBtn.classList.remove('active');
                canvas.classList.remove('eraser');
            } else {
                eraserBtn.classList.add('active');
                penBtn.classList.remove('active');
                canvas.classList.add('eraser');
            }
        }

        function clearAll() {
            if (confirm('„Ç≠„É£„É≥„Éê„Çπ„Çí„ÇØ„É™„Ç¢„Åó„Åæ„Åô„ÅãÔºü')) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGrid();
            }
        }

        // ==================== Drawing ====================
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        function setupDrawing() {
            // Mouse events
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseleave', stopDrawing);

            // Touch events
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                canvas.dispatchEvent(mouseEvent);
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                canvas.dispatchEvent(mouseEvent);
            });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                const mouseEvent = new MouseEvent('mouseup', {});
                canvas.dispatchEvent(mouseEvent);
            });
        }

        function getCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        function startDrawing(e) {
            isDrawing = true;
            const pos = getCoordinates(e);
            lastX = pos.x;
            lastY = pos.y;
        }

        function draw(e) {
            if (!isDrawing) return;

            const pos = getCoordinates(e);

            if (state.tool === 'pen') {
                ctx.strokeStyle = COLOR_MAP[state.currentColor];
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
            } else if (state.tool === 'eraser') {
                const eraserSize = 30;
                ctx.clearRect(pos.x - eraserSize / 2, pos.y - eraserSize / 2, eraserSize, eraserSize);
                // Redraw grid in erased area
                ctx.save();
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.08)';
                ctx.lineWidth = 1;

                const w = canvas.width;
                const h = canvas.height;

                for (let i = 1; i < 16; i++) {
                    const x = (w / 16) * i;
                    if (x >= pos.x - eraserSize / 2 && x <= pos.x + eraserSize / 2) {
                        ctx.beginPath();
                        ctx.moveTo(x, Math.max(0, pos.y - eraserSize / 2));
                        ctx.lineTo(x, Math.min(h, pos.y + eraserSize / 2));
                        ctx.stroke();
                    }
                }

                for (let i = 1; i < 12; i++) {
                    const y = (h / 12) * i;
                    if (y >= pos.y - eraserSize / 2 && y <= pos.y + eraserSize / 2) {
                        ctx.beginPath();
                        ctx.moveTo(Math.max(0, pos.x - eraserSize / 2), y);
                        ctx.lineTo(Math.min(w, pos.x + eraserSize / 2), y);
                        ctx.stroke();
                    }
                }
                ctx.restore();
            }

            lastX = pos.x;
            lastY = pos.y;
        }

        function stopDrawing() {
            isDrawing = false;
        }

        // ==================== Playback ====================
        function play() {
            if (state.isPlaying) return;

            // Initialize audio context on user interaction
            initAudio();

            // Save canvas state before playback
            state.canvasSnapshot = ctx.getImageData(0, 0, canvas.width, canvas.height);
            state.activeFlashes = [];

            state.isPlaying = true;
            state.playbackPosition = 0;
            state.lastTime = performance.now();
            state.lastPlaybackX = -10;

            playbackLine.style.display = 'block';

            state.animationId = requestAnimationFrame(animate);
        }

        function stop() {
            state.isPlaying = false;
            state.playbackPosition = 0;
            state.lastPlaybackX = -10;

            if (state.animationId) {
                cancelAnimationFrame(state.animationId);
                state.animationId = null;
            }

            // Restore canvas to remove flash effects
            if (state.canvasSnapshot) {
                ctx.putImageData(state.canvasSnapshot, 0, 0);
                state.canvasSnapshot = null;
            }

            playbackLine.style.display = 'none';
            playbackLine.style.left = '0%';
        }

        function animate(currentTime) {
            if (!state.isPlaying) return;

            // Handle first frame
            if (!currentTime) {
                state.animationId = requestAnimationFrame(animate);
                return;
            }

            const deltaTime = currentTime - state.lastTime;
            state.lastTime = currentTime;

            // Move playback position (1200px in 5 seconds at 1x speed)
            const baseSpeed = 1200 / (5 * 1000); // pixels per ms
            state.playbackPosition += deltaTime * baseSpeed * state.speed;

            // Loop when reaching the end
            if (state.playbackPosition >= canvas.width) {
                state.playbackPosition = 0;
                state.lastPlaybackX = -10;
                state.activeFlashes = [];
            }

            // Restore original canvas and redraw flashes
            if (state.canvasSnapshot) {
                ctx.putImageData(state.canvasSnapshot, 0, 0);

                // Redraw active flashes
                state.activeFlashes.forEach(flash => {
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = flash.color;
                    ctx.globalAlpha = flash.alpha;
                    ctx.beginPath();
                    ctx.arc(flash.x, flash.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });

                // Fade out flashes
                state.activeFlashes = state.activeFlashes.map(flash => ({
                    ...flash,
                    alpha: flash.alpha * 0.9
                })).filter(flash => flash.alpha > 0.05);
            }

            // Update playback line position
            const percentage = (state.playbackPosition / canvas.width) * 100;
            playbackLine.style.left = percentage + '%';

            // Check for intersections and play notes
            checkAndPlayNotes(Math.floor(state.playbackPosition));

            state.animationId = requestAnimationFrame(animate);
        }

        function checkAndPlayNotes(x) {
            // Only check new positions (skip if we've already checked this x)
            if (x <= state.lastPlaybackX || x >= canvas.width) return;

            // Get pixel data at this x position
            const imageData = ctx.getImageData(x, 0, 1, canvas.height);
            const data = imageData.data;

            const playedNotes = new Map(); // Track notes by color to avoid duplicates

            for (let y = 0; y < canvas.height; y++) {
                const i = y * 4;
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const a = data[i + 3];

                // Only detect fully opaque pixels (drawn lines, not grid or artifacts)
                if (a > 200) {
                    // Determine color and timbre
                    const colorInfo = getColorFromRGB(r, g, b);
                    if (colorInfo) {
                        const frequency = yToFrequency(y, canvas.height);
                        const key = `${colorInfo.timbre}_${Math.round(frequency)}`;

                        if (!playedNotes.has(key)) {
                            playNote(frequency, colorInfo.timbre);
                            flashIntersection(x, y, colorInfo.color);
                            playedNotes.set(key, true);
                        }
                    }
                }
            }

            state.lastPlaybackX = x;
        }

        function getColorFromRGB(r, g, b) {
            // Exclude gray colors (grid lines and background)
            const maxDiff = Math.max(Math.abs(r - g), Math.abs(g - b), Math.abs(r - b));
            if (maxDiff < 50) return null; // Too close to gray

            // Match RGB to our color palette (only vibrant colors)
            if (r > 200 && g < 150 && b < 150) return { color: 'red', timbre: 'square' };
            if (r < 150 && g > 150 && b > 200) return { color: 'blue', timbre: 'triangle' };
            if (r < 150 && g > 200 && b < 200) return { color: 'green', timbre: 'sawtooth' };
            if (r > 200 && g > 200 && b < 150) return { color: 'yellow', timbre: 'sine' };
            return null;
        }

        function flashIntersection(x, y, color) {
            // Add flash to active flashes array
            state.activeFlashes.push({
                x: x,
                y: y,
                color: COLOR_MAP[color],
                alpha: 0.8
            });
        }

        // ==================== Start Application ====================
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
